# Module 9.2: Creating & Updating Signals

**Objective:** To learn the syntax for declaring signals, reading their values, and updating them using the `set()` and `update()` methods.

---

### Declaring a Signal

Signals are created using the `signal()` function from `@angular/core`. When you create a signal, you must provide its initial value.

**Syntax:**

```typescript
import { signal } from '@angular/core';

const mySignal = signal<Type>(initialValue);
```

*   `signal<Type>`: The generic type parameter `Type` is optional but highly recommended for type safety.
*   `initialValue`: The initial value that the signal will hold.

**Example:**

```typescript
import { Component, signal } from '@angular/core';

@Component({
  standalone: true,
  selector: 'app-signal-demo',
  template: `
    <p>Count: {{ count() }}</p>
    <p>Name: {{ name() }}</p>
    <p>Is Active: {{ isActive() }}</p>
  `
})
export class SignalDemoComponent {
  // Declare a signal for a number with initial value 0
  count = signal(0);

  // Declare a signal for a string with initial value 'Alice'
  name = signal('Alice');

  // Declare a signal for a boolean with initial value true
  isActive = signal(true);

  // Declare a signal for an object
  user = signal({
    id: 1,
    username: 'john.doe',
    email: 'john@example.com'
  });
}
```

### Reading a Signal's Value

To read the current value of a signal, you call it like a function.

**Syntax:** `mySignal()`

**Example:**

```typescript
// In the component class
const currentCount = this.count(); // Reads the current value of the count signal
console.log(currentCount); // Output: 0

// In the template (as seen above)
<p>Count: {{ count() }}</p>
```

**Important:** Calling a signal like a function (`count()`) is how Angular tracks dependencies. When `count()` is called within a template, a `computed` signal, or an `effect`, Angular knows that this consumer depends on the `count` signal. When `count` changes, Angular will automatically re-evaluate the dependent consumer.

--- 

### Updating a Signal's Value

Signals provide two primary methods for updating their values: `set()` and `update()`.

#### 1. `set()`: Replacing the Entire Value

*   **What it does:** Replaces the signal's current value with a completely new value.
*   **Use Case:** When you want to assign a new, independent value to the signal.

**Syntax:** `mySignal.set(newValue)`

**Example:**

```typescript
import { Component, signal } from '@angular/core';

@Component({
  standalone: true,
  selector: 'app-signal-updater',
  template: `
    <p>Count: {{ count() }}</p>
    <button (click)="resetCount()">Reset Count</button>
    <button (click)="setCountToTen()">Set to 10</button>

    <p>User: {{ user().username }} ({{ user().email }})</p>
    <button (click)="changeUserEmail()">Change User Email</button>
  `
})
export class SignalUpdaterComponent {
  count = signal(0);
  user = signal({
    id: 1,
    username: 'john.doe',
    email: 'john@example.com'
  });

  resetCount(): void {
    this.count.set(0); // Resets count to 0
  }

  setCountToTen(): void {
    this.count.set(10); // Sets count to 10
  }

  changeUserEmail(): void {
    // When updating objects, you typically create a new object
    // to ensure immutability and proper change detection.
    this.user.set({
      ...this.user(), // Spread existing properties
      email: 'new.john@example.com' // Override email
    });
  }
}
```

#### 2. `update()`: Updating Based on the Current Value

*   **What it does:** Allows you to update a signal's value based on its current value. It takes a function that receives the current value as an argument and returns the new value.
*   **Use Case:** Incrementing a counter, toggling a boolean, or modifying properties of an object or array.

**Syntax:** `mySignal.update(currentValue => newCalculatedValue)`

**Example:**

```typescript
import { Component, signal } from '@angular/core';

@Component({
  standalone: true,
  selector: 'app-signal-updater-update',
  template: `
    <p>Count: {{ count() }}</p>
    <button (click)="incrementCount()">Increment</button>
    <button (click)="decrementCount()">Decrement</button>

    <p>User: {{ user().username }} ({{ user().email }})</p>
    <button (click)="updateUserUsername()">Update Username</button>
  `
})
export class SignalUpdaterUpdateComponent {
  count = signal(0);
  user = signal({
    id: 1,
    username: 'john.doe',
    email: 'john@example.com'
  });

  incrementCount(): void {
    this.count.update(currentCount => currentCount + 1); // Increments count by 1
  }

  decrementCount(): void {
    this.count.update(currentCount => currentCount - 1); // Decrements count by 1
  }

  updateUserUsername(): void {
    this.user.update(currentUser => ({
      ...currentUser,
      username: 'jane.doe' // Update only the username
    }));
  }
}
```

**When to use `set()` vs. `update()`:**

*   Use `set()` when you have a completely new value that doesn't depend on the signal's current state.
*   Use `update()` when the new value is derived from the signal's current value. This is particularly useful for objects and arrays, as it encourages creating new instances (immutability) while modifying specific properties.

Understanding how to declare, read, and update signals is the first step to leveraging Angular's new fine-grained reactivity system. In the next sections, we will explore how to derive state from signals and how to perform side effects in response to signal changes.

---

**Previous:** [9.1 What Are Angular Signals?](./9.1-what-are-signals.md)

**Next:** [9.3 Computed Signals](./9.3-computed-signals.md)
