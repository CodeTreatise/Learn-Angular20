# Module 9.1: What Are Angular Signals?

**Objective:** To understand the concept of Angular Signals, their purpose in the new reactivity model, and how they differ from and complement RxJS Observables.

---

### The Evolution of Reactivity in Angular

For a long time, Angular's change detection mechanism primarily relied on **Zone.js**. Zone.js patches asynchronous browser APIs (like `setTimeout`, `addEventListener`, `XMLHttpRequest`) to notify Angular whenever an asynchronous operation completes. This triggers Angular's change detection, which then re-renders the parts of the UI that might have changed.

While Zone.js is powerful and makes change detection largely automatic, it has some drawbacks:

*   **Performance Overhead:** Zone.js can be heavy, and its broad patching can sometimes trigger more change detection cycles than necessary.
*   **Debugging Complexity:** It can be challenging to pinpoint exactly *why* a change detection cycle was triggered.
*   **Bundle Size:** Zone.js adds to the application's bundle size.

To address these concerns and provide a more fine-grained, performant, and explicit reactivity model, Angular introduced **Signals**.

### What are Signals?

Signals are a new primitive in Angular's reactivity system. They are **wrapper objects that contain a value** and notify interested consumers when that value changes. They are designed for **fine-grained reactivity**, meaning only the specific parts of the UI that depend on a signal's value will be re-rendered when it changes.

```mermaid
%%{init: {'theme':'neutral'}}%%
graph TD
    A[Signal (Value)] --> B{Component 1 (uses Signal)};
    A --> C{Component 2 (uses Signal)};
    A --> D{Computed Signal (derives from Signal)};
    A --> E{Effect (reacts to Signal changes)};

    B -- updates --> A;
    C -- updates --> A;

    subgraph Reactivity Flow
        direction LR
        A -- notifies --> B, C, D, E;
    end
```
**Alt text:** Diagram illustrating Angular Signal reactivity flow. A central Signal (Value) notifies Component 1, Component 2, a Computed Signal, and an Effect when its value changes. Component 1 and Component 2 can also update the central Signal.

#### Key Characteristics of Signals:

1.  **Always Have a Value:** A signal always holds a value. When you create it, you provide an initial value.
2.  **Read-Only by Default:** To read a signal's value, you call it like a function (e.g., `mySignal()`). This function call is how Angular tracks dependencies.
3.  **Explicit Updates:** To change a signal's value, you use specific methods like `set()` or `update()`. This makes state changes explicit and easy to trace.
4.  **Fine-Grained Reactivity:** When a signal's value changes, only the components or expressions that directly depend on that signal are marked for re-rendering. This is more efficient than Zone.js's broader change detection.
5.  **No Zone.js Dependency (Potentially):** Signals are designed to work independently of Zone.js. In the future, it might be possible to run Angular applications without Zone.js entirely, leading to smaller bundle sizes and better performance.

--- 

### Signals vs. RxJS Observables

While both Signals and Observables are powerful tools for handling asynchronous data, they serve different primary purposes and have distinct characteristics.

| Feature           | Signals                                       | RxJS Observables                                  |
| :---------------- | :-------------------------------------------- | :------------------------------------------------ |
| **Primary Use**   | **State management**, fine-grained reactivity, local component state. | **Asynchronous data streams**, event handling, HTTP requests. |
| **Value Emission**| Always has a current value. Emits new values when `set()` or `update()` is called. | Can emit zero, one, or many values over time. Can complete or error. |
| **Execution**     | **Eager** (always has a value).               | **Lazy** (only executes when subscribed to).      |
| **Cancellable**   | Not directly cancellable (you manage the signal's lifecycle). | Easily cancellable via `unsubscribe()`.           |
| **Immutability**  | Values are typically immutable (you `set()` a new value). | Values can be mutable or immutable depending on usage. |
| **Composition**   | `computed()` for derived state, `effect()` for side effects. | Rich ecosystem of operators (`map`, `filter`, `switchMap`, etc.). |
| **Error Handling**| Handled by `effect()` or external logic.      | Built-in `catchError` operator.                   |
| **Integration**   | Native to Angular, designed for change detection. | General-purpose reactive programming library.     |

**When to use which?**

*   **Use Signals for:**
    *   Component local state.
    *   Application-wide state that needs fine-grained reactivity.
    *   Derived state (`computed`).
    *   Side effects that react to state changes (`effect`).

*   **Use RxJS Observables for:**
    *   HTTP requests (`HttpClient` returns Observables).
    *   User input events (e.g., `fromEvent`).
    *   Real-time data streams (e.g., WebSockets).
    *   Complex asynchronous flows that require powerful operators like `switchMap`, `debounceTime`, etc.

**They are not mutually exclusive.** In a typical Angular application, you will use both. For example, you might fetch data using `HttpClient` (which returns an Observable), convert that Observable into a Signal, and then use the Signal to update your UI.

Signals represent a significant step forward in Angular's reactivity story, offering a more performant and explicit way to manage state, while complementing the existing power of RxJS.

---

**Previous:** [8.5 Introduction to NgRx (Briefly)](../08-rxjs-and-state-management/8.5-introduction-to-ngrx.md)

**Next:** [9.2 Creating & Updating Signals](./9.2-creating-updating-signals.md)
