# Module 7.3: HTTP Interceptors

**Objective:** By the end of this module, you will be able to understand the concept of HTTP Interceptors, implement them to globally transform HTTP requests and responses, and apply them for common tasks like authentication, logging, and centralized error handling.

---

### The Power of Interception

In many applications, you need to perform the same operation on every outgoing HTTP request or every incoming HTTP response. For example:

*   Adding an authentication token to every outgoing request.
*   Logging all HTTP requests and their responses.
*   Displaying a loading spinner for every active request.
*   Transforming response data before it reaches the component (e.g., normalizing API responses).
*   Centralized error handling for specific HTTP status codes.

Instead of repeating this logic in every service or component that makes an HTTP call, Angular provides **HTTP Interceptors**. An interceptor is a class that implements the `HttpInterceptor` interface, allowing you to intercept and modify HTTP requests and responses globally.

```mermaid
graph TD
    A[Angular App] --> B{HttpClient Request};
    B --> C[Interceptor 1];
    C --> D[Interceptor 2];
    D --> E[Backend API];
    E --> F[Interceptor 2 Response];
    F --> G[Interceptor 1 Response];
    G --> H[Angular App (Response)];

    subgraph Interceptor Chain
        direction LR
        C -- next.handle() --> D;
        D -- next.handle() --> C;
        C -- next.handle() --> E;
        E -- returns --> D;
        D -- returns --> C;
    end
```

### How Interceptors Work

Interceptors form a chain. When an HTTP request is made, it passes through each interceptor in the order they are provided. Each interceptor can:

*   Inspect and modify the outgoing `HttpRequest`.
*   Pass the modified request to the next interceptor in the chain (or to the `HttpClient` if it's the last one).
*   Inspect and modify the incoming `HttpResponse`.

**Advanced Use Cases:** Interceptors can also be used for more complex scenarios like caching HTTP responses, retrying failed requests with specific logic, or even short-circuiting requests (e.g., if data is already in a local cache, prevent the request from going to the backend).

#### The `intercept()` Method

An interceptor class must implement the `HttpInterceptor` interface, which requires a single method: `intercept()`.

```typescript
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';
import { Observable } from 'rxjs';

export class MyInterceptor implements HttpInterceptor {
  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    // Logic to modify the request
    // Logic to handle the response
    return next.handle(request);
  }
}
```

*   **`request: HttpRequest<any>`**: The outgoing request object. It's important to note that `HttpRequest` objects are **immutable**. To modify a request, you must clone it and then modify the clone.
*   **`next: HttpHandler`**: Represents the next interceptor in the chain. You call `next.handle(request)` to pass the (potentially modified) request to the next handler.
*   **`Observable<HttpEvent<any>>`**: The `intercept` method must return an observable of `HttpEvent`s. This stream will eventually contain the `HttpResponse`. **It is crucial to always return `next.handle(request)` (or a new observable) to ensure the request continues down the chain and the response is eventually received.** Failing to do so will cause the request to hang.

--- 

### Common Interceptor Use Cases

#### 1. Authentication Interceptor (Adding Auth Headers)

This is one of the most common uses: automatically adding an `Authorization` header (e.g., a JWT token) to every outgoing request.

```typescript
// src/app/auth.interceptor.ts
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';
import { Observable } from 'rxjs';
import { AuthService } from './auth.service'; // Assume you have an AuthService

@Injectable()
export class AuthInterceptor implements HttpInterceptor {

  constructor(private authService: AuthService) { }

  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const authToken = this.authService.getToken(); // Get token from your auth service

    // Clone the request and add the Authorization header if a token exists
    if (authToken) {
      request = request.clone({
        setHeaders: {
          Authorization: `Bearer ${authToken}`
        }
      });
    }

    // Pass the cloned request to the next handler
    return next.handle(request);
  }
}
```

**Security Tip:** Be extremely careful with sensitive information like authentication tokens. Never log them directly to the console in production environments, and ensure they are transmitted securely (e.g., over HTTPS).

#### 2. Logging Interceptor

This interceptor logs details about requests and responses, useful for debugging.

```typescript
// src/app/logging.interceptor.ts
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpResponse } from '@angular/common/http';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class LoggingInterceptor implements HttpInterceptor {
  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const started = Date.now();
    let ok: string;

    // Log the outgoing request
    console.log(`Outgoing request: ${request.method} ${request.url}`);

    return next.handle(request).pipe(
      tap({
        next: (event: HttpEvent<any>) => {
          if (event instanceof HttpResponse) {
            ok = event.ok ? 'succeeded' : 'failed';
            const elapsed = Date.now() - started;
            console.log(`Incoming response: ${request.method} ${request.url} ${ok} in ${elapsed} ms`);
          }
        },
        error: (error) => {
          ok = 'failed';
          const elapsed = Date.now() - started;
          console.error(`Request failed: ${request.method} ${request.url} in ${elapsed} ms`, error);
        }
      })
    );
  }
}
```

**Production Logging:** In production environments, it's generally advisable to limit the verbosity of logging interceptors to avoid exposing sensitive information or impacting performance. Consider using a dedicated logging service that sends errors to a remote monitoring system rather than logging directly to the console.

--- 

### Providing Interceptors

To make your interceptors active, you need to provide them at the application level. In a standalone application, this is done in `app.config.ts` using `provideHttpClient` and `withInterceptors`.

```typescript
// src/app/app.config.ts
import { ApplicationConfig } from '@angular/core';
import { provideRouter } from '@angular/router';
import { provideHttpClient, withInterceptors } from '@angular/common/http';

// Import your interceptors
import { AuthInterceptor } from './auth.interceptor';
import { LoggingInterceptor } from './logging.interceptor';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes),
    provideHttpClient(
      withInterceptors([
        AuthInterceptor, // Order matters! Auth usually first.
        LoggingInterceptor
      ])
    )
  ]
};
```

**Note for NgModule-based applications:** In traditional Angular applications using `NgModule`s, interceptors are provided in the `providers` array of your `AppModule` or a feature module, using the `HTTP_INTERCEPTORS` token and `multi: true`.

```typescript
// In app.module.ts (NgModule-based)
import { HTTP_INTERCEPTORS } from '@angular/common/http';
import { AuthInterceptor } from './auth.interceptor';

@NgModule({
  // ...
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },
    // ... other providers
  ],
  // ...
})
export class AppModule { }
```

**Important Considerations:**

*   **Order Matters:** Interceptors are executed in the order they are provided in the `withInterceptors` array. The first interceptor in the array will be the first to process the outgoing request and the last to process the incoming response.
*   **Immutability:** Remember that `HttpRequest` objects are immutable. Always `clone()` the request before modifying it.
*   **Error Handling:** Interceptors can also be used for centralized error handling, as shown in the logging example's `tap` operator with an `error` callback.

**Testing HTTP Interceptors:** You can unit test your interceptors in isolation using `HttpClientTestingModule` and `HttpTestingController` to mock HTTP requests and responses. This allows you to verify that your interceptor correctly modifies requests or handles responses. (See [Module 13.3: Unit Testing Services and Pipes](../13-testing/13.3-unit-testing-services-pipes.md) for more details).

HTTP Interceptors are a powerful feature for managing cross-cutting concerns in your Angular application's HTTP communication. They promote clean code, reusability, and maintainability by centralizing common HTTP-related tasks.

---

### Key Takeaways

*   **HTTP Interceptors** allow you to intercept and modify HTTP requests and responses globally.
*   They are ideal for cross-cutting concerns like **authentication**, **logging**, **caching**, and **error handling**.
*   Interceptors form a **chain**, executing in the order they are provided.
*   `HttpRequest` objects are **immutable**, requiring `clone()` for modifications.
*   Always return `next.handle(request)` (or a new observable) from the `intercept()` method.
*   In standalone apps, interceptors are provided using `provideHttpClient(withInterceptors([...]))`.

---

### Hands-on Exercise: Create an Auth Token Interceptor

1.  **Create a simple `AuthService`** with a `getToken()` method that returns a hard-coded fake JWT token (e.g., `'my-secret-auth-token'`).
2.  **Generate an `AuthInterceptor`** using the CLI: `ng g interceptor auth`.
3.  **Implement the `intercept` method** in your `AuthInterceptor`. It should:
    *   Get the token from the `AuthService`.
    *   If a token exists, clone the outgoing request and add an `Authorization` header with the value `Bearer <your-token>`.
    *   Pass the (potentially cloned) request to `next.handle()`.
4.  **Provide the interceptor** in your `app.config.ts` using `provideHttpClient(withInterceptors([AuthInterceptor]))`.
5.  **Create a `DataService`** that makes a GET request to a public API (e.g., `https://jsonplaceholder.typicode.com/posts/1`).
6.  **Call the `DataService` method** from a component and open your browser's developer tools.
7.  **Verify in the "Network" tab** that the outgoing request to the API now includes the `Authorization` header.

---

**End of Module 7.**

**Previous:** [7.2 Handling Responses and Errors](./7.2-handling-responses-errors.md)

**Next:** [08-rxjs-and-state-management](../08-rxjs-and-state-management)
