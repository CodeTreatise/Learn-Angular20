# Module 3.3: Standalone Component Dependencies

**Objective:** By the end of this module, you will be able to effectively declare and manage component-level dependencies using the `imports` array in standalone components, and understand the process of migrating `NgModule`-based components to standalone.

---

### The `imports` Array: A Component's Lifeline

With standalone components, the responsibility of declaring dependencies shifts from the `NgModule` to the component itself. The `imports` array within the `@Component` decorator is where a standalone component explicitly declares everything it needs.

This improves testability and reusability, as the component is now self-contained.

```mermaid
graph TD
    subgraph Standalone Component
        A[Component Class]
        B[Template]
        C[Styles]
    end

    subgraph @Component Decorator
        D[selector]
        E[templateUrl/template]
        F[styleUrls/styles]
        G[standalone: true]
        H[imports: [ ... ]]
    end

    H -- imports --> I[Other Standalone Components];
    H -- imports --> J[Directives];
    H -- imports --> K[Pipes];
    H -- imports --> L[NgModules (if needed)];

    A -- configured by --> H;
    B -- uses --> I, J, K;
```

### What Goes into the `imports` Array?

1.  **Other Standalone Components:** If your component's template uses another standalone component, you must import it.
2.  **Directives:** Any standalone directives used in your template must be imported.
3.  **Pipes:** Any standalone pipes used in your template must be imported.
4.  **`NgModule`s:** You might still need to import traditional `NgModule`s for certain features. Common examples include `FormsModule`, `ReactiveFormsModule`, and third-party library modules like `MatButtonModule`.

### Practical Examples

#### Example 1: Using a Child Standalone Component

**`user-profile.component.ts` (Parent Standalone Component):**
```typescript
import { Component } from '@angular/core';
import { UserAvatarComponent } from './user-avatar.component'; // Import the child component

@Component({
  standalone: true,
  selector: 'app-user-profile',
  template: `<app-user-avatar [avatarUrl]="'...'" />`,
  imports: [UserAvatarComponent] // Declare the dependency here
})
export class UserProfileComponent {}
```

#### Example 2: Using `FormsModule` for Two-Way Binding

`[(ngModel)]` requires `FormsModule`. Note that `FormsModule` itself is not standalone as of Angular 17, so you import the module.

**`login.component.ts` (Standalone Component):**
```typescript
import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms';

@Component({
  standalone: true,
  selector: 'app-login',
  template: `<input [(ngModel)]="username">`,
  imports: [FormsModule] // Add FormsModule to imports
})
export class LoginComponent {
  username: string = '';
}
```

#### Example 3: Using Common Directives

Common directives like `@if`, `@for`, `ngClass`, and `ngStyle` are available automatically in standalone components. You do not need to import `CommonModule`.

### Best Practices for `imports`

*   **Be Explicit:** Only import what your component directly uses. This improves tree-shaking.
*   **Keep it Clean:** A long `imports` array might indicate that your component should be broken down.

### Real-World Example: Migration

Migrating a component from `NgModule` to standalone simplifies its structure.

#### Before: The NgModule-Based Approach

**`product-card.component.ts`**
```typescript
@Component({ ... })
export class ProductCardComponent { ... }
```

**`products.module.ts`**
```typescript
@NgModule({
  declarations: [ProductCardComponent, CustomCurrencyPipe],
  imports: [CommonModule, TooltipModule],
  exports: [ProductCardComponent]
})
export class ProductsModule { }
```

#### After: The Standalone Approach

We can eliminate `products.module.ts` and make the component self-contained.

**`product-card.component.ts` (Standalone)**
```typescript
@Component({
  standalone: true,
  selector: 'app-product-card',
  template: `...`,
  imports: [CustomCurrencyPipe, TooltipModule]
})
export class ProductCardComponent { ... }
```

This direct dependency management simplifies the component's mental model and improves its portability. For detailed migration steps, refer to the [official Angular migration guide](https://angular.io/guide/standalone-migration).

---

### Key Takeaways

*   Standalone components declare their dependencies directly in the `imports` array.
*   The `imports` array can include other standalone components, directives, pipes, and `NgModule`s.
*   Migrating to standalone components simplifies the project structure and reduces boilerplate.

---

**End of Module 3.**

**Previous:** [3.2 Creating & Bootstrapping a Standalone App](./3.2-bootstrapping.md)

**Next:** [04-services-and-di](../04-services-and-di/4.1-purpose-of-services.md)
