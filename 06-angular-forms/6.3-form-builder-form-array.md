# Module 6.3: Reactive Forms: `FormBuilder` & `FormArray`

**Objective:** By the end of this module, you will be able to:
- **Simplify** the creation of `FormControl` and `FormGroup` instances using `FormBuilder`.
- **Effectively manage** dynamic, repeatable form fields with `FormArray`.
- **Understand** how to validate and access data from `FormArray`.

---

### 1. `FormBuilder`: A Convenient Way to Build Forms

While directly instantiating `FormControl` and `FormGroup` works, it can become verbose for larger forms. The `FormBuilder` service provides a more concise and readable syntax for creating form models.

#### a) Using `FormBuilder`

To use `FormBuilder`, you need to inject it into your component's constructor.

**Example (Refactoring from 6.2):**

```typescript
import { Component } from '@angular/core';
import { ReactiveFormsModule, FormBuilder, Validators, FormGroup } from '@angular/forms';

@Component({
  standalone: true,
  selector: 'app-user-registration-fb',
  imports: [ReactiveFormsModule],
  template: `
    <form [formGroup]="userForm" (ngSubmit)="onSubmit()">
      <label>First Name:
        <input type="text" formControlName="firstName">
      </label>
      <label>Last Name:
        <input type="text" formControlName="lastName">
      </label>

      <div formGroupName="contact">
        <label>Email:
          <input type="email" formControlName="email">
        </label>
        <label>Phone:
          <input type="tel" formControlName="phone">
        </label>
      </div>

      <button type="submit" [disabled]="userForm.invalid">Register</button>
    </form>
  `
})
export class UserRegistrationFbComponent {
  userForm: FormGroup; // Declare the type

  constructor(private fb: FormBuilder) { // Inject FormBuilder
    this.userForm = this.fb.group({
      firstName: ['', Validators.required], // Array syntax: [initialValue, validators]
      lastName: ['', Validators.required],
      contact: this.fb.group({
        email: ['', [Validators.required, Validators.email]],
        phone: ['']
      })
    });
  }

  onSubmit(): void {
    console.log('Form Submitted!', this.userForm.value);
  }
}
```

**`FormBuilder` Methods:**

*   `fb.group(object)`: Creates a `FormGroup`. Each property in the object can be:
    *   A `FormControl` instance.
    *   An array: `[initialValue, validators, asyncValidators]`.
*   `fb.control(initialValue, validators, asyncValidators)`: Creates a `FormControl`.
*   `fb.array(array)`: Creates a `FormArray` (discussed next).

**Tip on Custom Validators:** You can easily add custom validators to your form controls or groups when using `FormBuilder`. For example, `firstName: ['', [Validators.required, myCustomValidator]]`.

**Benefits of `FormBuilder`:**

*   **Conciseness:** Reduces boilerplate, especially for complex forms.
*   **Readability:** The form structure is often clearer.

--- 

### 2. `FormArray`: Managing Dynamic Lists of Controls

`FormArray` is a way to manage a dynamic collection of `FormControl`, `FormGroup`, or even other `FormArray` instances. It's perfect for scenarios where you need to add or remove form fields at runtime, such as a list of phone numbers, skills, or addresses.

**Note on Performance:** For very large `FormArray`s (hundreds or thousands of items), consider implementing virtual scrolling or pagination to optimize rendering performance and user experience.

#### a) Creating a `FormArray`

You can create a `FormArray` using `FormBuilder` or by directly instantiating it.

**Example: A User Profile with Multiple Skills**

```typescript
import { Component } from '@angular/core';
import { ReactiveFormsModule, FormBuilder, FormGroup, FormArray, FormControl, Validators } from '@angular/forms';

@Component({
  standalone: true,
  selector: 'app-user-skills',
  imports: [ReactiveFormsModule],
  template: `
    <form [formGroup]="userProfileForm" (ngSubmit)="onSubmit()">
      <label>Name:
        <input type="text" formControlName="name">
      </label>

      <h3>Skills:</h3>
      <div formArrayName="skills">
        @for (skillControl of skills.controls; track $index) {
          <div class="skill-item">
            <input type="text" [formControlName]="$index">
            <button type="button" (click)="removeSkill($index)">Remove</button>
          </div>
        }
      </div>
      <button type="button" (click)="addSkill()">Add Skill</button>

      <button type="submit" [disabled]="userProfileForm.invalid">Save Profile</button>
    </form>
  `,
  styles: [`
    .skill-item { margin-bottom: 5px; }
    input { margin-right: 10px; }
  `]
})
export class UserSkillsComponent {
  userProfileForm: FormGroup;

  constructor(private fb: FormBuilder) {
    this.userProfileForm = this.fb.group({
      name: ['', Validators.required],
      skills: this.fb.array([ // Initialize with an empty FormArray or some default skills
        this.fb.control('Angular'),
        this.fb.control('TypeScript')
      ])
    });
  }

  // Getter to easily access the skills FormArray
  get skills(): FormArray {
    return this.userProfileForm.get('skills') as FormArray;
  }

  addSkill(): void {
    this.skills.push(this.fb.control('', Validators.required)); // Add a new FormControl to the FormArray
  }

  removeSkill(index: number): void {
    this.skills.removeAt(index);
  }

  onSubmit(): void {
    if (this.userProfileForm.valid) {
      console.log('User Profile:', this.userProfileForm.value);
    } else {
      console.log('Form is invalid.');
    }
  }
}
```

**Tip on Validating FormArray Controls:** You can add validators to individual controls within a `FormArray` (as shown with `Validators.required` in `addSkill()`). The `FormArray`'s `valid` status will reflect the validity of all its contained controls.

#### b) Binding `FormArray` to the Template

*   Use `formArrayName="skills"` on a container element (e.g., `<div>`) to link the HTML section to your `FormArray` instance.
*   Use `@for` to iterate over `skills.controls`. Each `FormControl` within the `FormArray` can be bound using `[formControlName]="$index"`, where `$index` refers to the current item's index in the array.

**Note on Accessibility for Dynamic Fields:** For dynamically added form fields, ensure proper ARIA attributes (e.g., `aria-live` for announcements, `aria-labelledby` for labels) are used to maintain accessibility for screen reader users.

#### c) Accessing `FormArray` Values and State

`FormArray` also has `value`, `valid`, `invalid`, etc., properties, which reflect the aggregated state of its child controls.

**Accessing Individual Controls in `FormArray`:**

You can access individual controls within a `FormArray` using the `at()` method with an index, or by iterating over the `controls` property.

```typescript
// Get the control at a specific index
const firstSkillControl = this.skills.at(0);

// Iterate over controls
this.skills.controls.forEach(control => {
  console.log(control.value);
});
```

**Tip on Resetting or Clearing FormArrays:** You can clear all controls from a `FormArray` using `this.skills.clear()`. To reset values to their initial state, you can use `this.skills.reset()`.

### Summary of Reactive Forms Hierarchy

```mermaid
%%{init: {'theme':'neutral'}}%%
graph TD
    A[FormGroup (Top-level Form)]
    A --> B[FormControl (Single Input)];
    A --> C[FormGroup (Nested Group of Inputs)];
    A --> D[FormArray (Dynamic List of Inputs/Groups)];

    C --> E[FormControl];
    D --> F[FormControl];
    D --> G[FormGroup];
    G --> H[FormControl];
```
**Alt text:** Diagram illustrating the hierarchical structure of Reactive Forms. A top-level FormGroup can contain individual FormControls, nested FormGroups, or dynamic FormArrays. Nested FormGroups can further contain FormControls, and FormArrays can contain either FormControls or other FormGroups, allowing for complex and flexible form structures.

**Text Summary of Reactive Forms Hierarchy:**

Reactive Forms are built using a hierarchical structure. A top-level `FormGroup` can contain individual `FormControl`s, nested `FormGroup`s, or dynamic `FormArray`s. Nested `FormGroup`s can further contain `FormControl`s, and `FormArray`s can contain either `FormControl`s or other `FormGroup`s, allowing for complex and flexible form structures.

`FormBuilder` and `FormArray` are powerful tools that significantly enhance your ability to build complex, dynamic, and maintainable forms with Angular Reactive Forms. They are essential for real-world applications that go beyond simple static inputs.

---

### Key Takeaways

*   **`FormBuilder`** provides a concise syntax for creating `FormControl`, `FormGroup`, and `FormArray` instances, reducing boilerplate.
*   **`FormArray`** is used to manage dynamic collections of form controls, perfect for repeatable form fields.
*   `FormArray` allows you to add, remove, and access controls dynamically.
*   Reactive Forms enable complex, nested form structures using `FormGroup` and `FormArray`.

---

**Previous:** [6.2 Reactive Forms: `FormControl` & `FormGroup`](./6.2-reactive-forms-basics.md)

**Next:** [6.4 Form Validation](./6.4-form-validation.md)
