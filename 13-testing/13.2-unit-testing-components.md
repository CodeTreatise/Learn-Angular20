# Module 13.2: Unit Testing Components

**Objective:** To learn how to write effective unit tests for Angular components, focusing on testing the component's class logic, its template interactions, and how to use `TestBed` for component testing.

---

### Testing Components: Class vs. Template

When unit testing an Angular component, you typically test two main aspects:

1.  **Component Class Logic:** This involves testing the methods, properties, and lifecycle hooks of the component's TypeScript class in isolation, similar to testing any other plain TypeScript class.
2.  **Template Interactions (DOM Testing):** This involves testing how the component's template renders, how it responds to user interactions (clicks, input), and how it displays data bound from the class.

```mermaid
%%{init: {'theme':'neutral'}}%%
graph TD
    A[Component Unit Testing] --> B{Test Component Class (Logic)};
    A --> C{Test Component Template (DOM)};

    B -- uses --> B1[Jasmine/Jest syntax];
    B -- mocks --> B2[Dependencies];

    C -- uses --> C1[TestBed];
    C -- uses --> C2[ComponentFixture];
    C -- uses --> C3[DebugElement];
```
**Alt text:** Diagram illustrating component unit testing, which involves testing the component class logic (using Jasmine/Jest syntax and mocking dependencies) and testing the component template/DOM (using TestBed, ComponentFixture, and DebugElement).

### Setting Up for Component Testing: `TestBed`

Angular provides the `TestBed` utility for creating a testing module that mimics an Angular `NgModule` (even for standalone components). `TestBed` configures and initializes the environment for your tests.

#### Basic `TestBed` Configuration

```typescript
import { TestBed, ComponentFixture } from '@angular/core/testing';
import { MyComponent } from './my.component';

describe('MyComponent', () => {
  let component: MyComponent;
  let fixture: ComponentFixture<MyComponent>;

  beforeEach(async () => {
    // Configure the testing module
    await TestBed.configureTestingModule({
      imports: [MyComponent], // Import the standalone component directly
      // providers: [ /* Mock services here */ ]
    }).compileComponents(); // Compile component's template and CSS

    // Create a component fixture (an instance of the component and its host element)
    fixture = TestBed.createComponent(MyComponent);
    component = fixture.componentInstance; // Get the component instance

    // Trigger initial change detection to bind data and render template
    fixture.detectChanges();
  });

  // ... your tests
});
```

**Key Elements:**

*   **`TestBed.configureTestingModule()`:** Sets up a testing module. For standalone components, you simply list them in the `imports` array.
*   **`compileComponents()`:** Asynchronously compiles the component's template and CSS. This is important for components with external templates/styles.
*   **`TestBed.createComponent()`:** Creates an instance of the component and its host element, returning a `ComponentFixture`.
*   **`ComponentFixture<T>`:** A wrapper around the component instance and its host element. It provides methods to interact with the component and trigger change detection.
    *   `componentInstance`: The actual instance of your component class.
    *   `nativeElement`: The root DOM element of the component.
    *   `debugElement`: A wrapper around the native element that provides more Angular-specific debugging capabilities.
*   **`fixture.detectChanges()`:** Triggers Angular's change detection cycle for the component. This is crucial for updating the view after changes to component properties.

--- 

### 1. Testing Component Class Logic

This is straightforward, as you're testing a plain TypeScript class. You can create an instance of the component directly.

**Example: Testing a Counter Component**

```typescript
// src/app/counter/counter.component.ts
import { Component } from '@angular/core';

@Component({
  standalone: true,
  selector: 'app-counter',
  template: `
    <p>Count: {{ count }}</p>
    <button (click)="increment()">+</button>
    <button (click)="decrement()">-</button>
  `
})
export class CounterComponent {
  count: number = 0;

  increment(): void {
    this.count++;
  }

  decrement(): void {
    this.count--;
  }
}
```

**Test File (`src/app/counter/counter.component.spec.ts`):**

```typescript
import { CounterComponent } from './counter.component';

describe('CounterComponent (Class Logic)', () => {
  let component: CounterComponent;

  beforeEach(() => {
    component = new CounterComponent(); // Directly instantiate the class
  });

  it('should create an instance', () => {
    expect(component).toBeTruthy();
  });

  it('should have a default count of 0', () => {
    expect(component.count).toBe(0);
  });

  it('should increment the count by 1', () => {
    component.increment();
    expect(component.count).toBe(1);
  });

  it('should decrement the count by 1', () => {
    component.decrement();
    expect(component.count).toBe(-1);
  });
});
```

--- 

### 2. Testing Template Interactions (DOM Testing)

This involves using `TestBed` to render the component and then interacting with its DOM elements.

**Example: Testing the Counter Component's Buttons**

```typescript
// src/app/counter/counter.component.spec.ts (continued)
import { TestBed, ComponentFixture } from '@angular/core/testing';
import { CounterComponent } from './counter.component';

describe('CounterComponent (DOM Interactions)', () => {
  let component: CounterComponent;
  let fixture: ComponentFixture<CounterComponent>;
  let compiled: HTMLElement; // The rendered DOM element

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [CounterComponent] // Import the standalone component
    }).compileComponents();

    fixture = TestBed.createComponent(CounterComponent);
    component = fixture.componentInstance;
    compiled = fixture.nativeElement; // Get the root DOM element

    fixture.detectChanges(); // Initial change detection
  });

  it('should display the initial count', () => {
    expect(compiled.querySelector('p')?.textContent).toContain('Count: 0');
  });

  it('should increment count when + button is clicked', () => {
    const incrementButton = compiled.querySelector('button:first-of-type');
    incrementButton?.click(); // Simulate a click
    fixture.detectChanges(); // Trigger change detection to update the view
    expect(compiled.querySelector('p')?.textContent).toContain('Count: 1');
  });

  it('should decrement count when - button is clicked', () => {
    const decrementButton = compiled.querySelector('button:last-of-type');
    decrementButton?.click(); // Simulate a click
    fixture.detectChanges(); // Trigger change detection
    expect(compiled.querySelector('p')?.textContent).toContain('Count: -1');
  });
});
```

**Key Techniques for DOM Testing:**

*   **`fixture.nativeElement`:** Provides direct access to the component's root DOM element. You can use standard DOM APIs (`querySelector`, `querySelectorAll`, `textContent`, `click()`) to inspect and interact with elements.
*   **`fixture.debugElement`:** A more Angular-specific way to query and interact with elements. It's useful for querying by directive, component, or CSS selector.
    ```typescript
    // Using DebugElement to find the button
    const incrementButton = fixture.debugElement.query(By.css('button:first-of-type'));
    incrementButton.triggerEventHandler('click', null); // Simulate event
    ```
*   **`fixture.detectChanges()`:** **Crucial!** After any action that changes the component's state (e.g., button click, input change, service response), you must call `fixture.detectChanges()` to tell Angular to run change detection and update the DOM.

### Mocking Dependencies

When testing a component that relies on services, you should **mock** those services to isolate the component under test. This prevents your component tests from becoming integration tests.

**Example: Component with a Service Dependency**

```typescript
// src/app/user-display/user-display.component.ts
import { Component, OnInit } from '@angular/core';
import { UserService } from '../user.service'; // Dependency

@Component({
  standalone: true,
  selector: 'app-user-display',
  template: `<p>User: {{ user?.name }}</p>`
})
export class UserDisplayComponent implements OnInit {
  user: { name: string } | undefined;

  constructor(private userService: UserService) { }

  ngOnInit(): void {
    this.userService.getUser().subscribe(user => {
      this.user = user;
    });
  }
}
```

**Test File (`src/app/user-display/user-display.component.spec.ts`):**

```typescript
import { TestBed, ComponentFixture } from '@angular/core/testing';
import { UserDisplayComponent } from './user-display.component';
import { UserService } from '../user.service';
import { of } from 'rxjs';

describe('UserDisplayComponent', () => {
  let component: UserDisplayComponent;
  let fixture: ComponentFixture<UserDisplayComponent>;
  let mockUserService: any; // Mock service

  beforeEach(async () => {
    // Create a mock for UserService
    mockUserService = {
      getUser: jasmine.createSpy('getUser').and.returnValue(of({ name: 'Test User' }))
    };

    await TestBed.configureTestingModule({
      imports: [UserDisplayComponent],
      providers: [
        { provide: UserService, useValue: mockUserService } // Provide the mock
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(UserDisplayComponent);
    component = fixture.componentInstance;
    fixture.detectChanges(); // ngOnInit will be called here
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should display user name from service', () => {
    expect(mockUserService.getUser).toHaveBeenCalled(); // Verify service method was called
    expect(fixture.nativeElement.querySelector('p')?.textContent).toContain('User: Test User');
  });
});
```

Unit testing components is a cornerstone of building reliable Angular applications. By isolating components and effectively mocking their dependencies, you can ensure that each part of your UI behaves exactly as intended.

---

**Previous:** [13.1 Introduction to Testing Your Angular Application](./13.1-introduction-to-testing.md)

**Next:** [13.3 Unit Testing Services and Pipes](./13.3-unit-testing-services-pipes.md)
