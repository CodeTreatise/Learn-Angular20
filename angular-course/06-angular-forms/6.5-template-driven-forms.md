# Module 6.5: Template-Driven Forms

**Objective:** By the end of this module, you will be able to:
- **Implement** Template-Driven Forms in Angular, focusing on their simplicity for basic use cases.
- **Understand** how they leverage directives like `ngModel` and `ngForm` for data binding and validation.
- **Apply** validation and display error messages effectively in Template-Driven Forms.


---

### The Template-Driven Approach: Simplicity in the HTML

Template-Driven Forms are an alternative to Reactive Forms, primarily suited for simpler form scenarios. In this approach, the form logic is largely handled directly within the HTML template using Angular directives. Angular automatically infers the form model from the directives you place in the template.

**Contrast with Reactive Forms:** While Reactive Forms build the form model programmatically in TypeScript, Template-Driven Forms build the model implicitly from directives in the HTML. This makes them quicker to set up for simple forms but offers less explicit control.

```mermaid
%%{init: {'theme':'neutral'}}%%
graph TD
    A[HTML Template] -- directives like ngModel, ngForm --> B{Angular Forms Module};
    B -- infers --> C[Form Model (behind the scenes)];
    C -- updates --> D[Component Data Model];
    D -- updates --> C;
    C -- updates --> A;
```
**Alt text:** Diagram illustrating the Template-Driven Forms data flow: The HTML Template, using directives like ngModel and ngForm, interacts with the Angular Forms Module. This module infers a Form Model (behind the scenes), which then updates the Component Data Model. Changes flow bidirectionally between the Component Data Model, the Form Model, and the HTML Template.

### When to Use Template-Driven Forms

*   **Simple Forms:** Ideal for forms with a small number of fields and straightforward validation rules.
*   **Quick Prototypes:** When you need to get a form up and running very quickly.
*   **Minimal Logic:** When most of the form logic can be expressed directly in the template.

**Limitations for Complex Forms:** For forms with dynamic fields (e.g., adding/removing inputs at runtime), complex validation rules, or forms that require programmatic manipulation, Template-Driven Forms quickly become cumbersome. In such cases, Reactive Forms are the superior choice.

### Advantages and Disadvantages

| Feature        | Advantages                                     | Disadvantages                                                                 |
| :------------- | :--------------------------------------------- | :---------------------------------------------------------------------------- |
| **Syntax**     | Less TypeScript code, more HTML-centric.       | Can become cluttered and hard to read for complex forms.                     |
| **Control**    | Easy to set up.                                | Less explicit programmatic control over form state and validation.            |
| **Testability**| Easier to unit test simple forms.              | Harder to unit test, as logic is intertwined with the template.               |
| **Scalability**| Quick for small, static forms.                 | Not suitable for dynamic forms or complex validation scenarios.               |
| **Learning Curve** | Lower for beginners familiar with HTML forms.  | Can lead to confusion when debugging complex interactions.                    |

### Setup: Importing `FormsModule`

To use Template-Driven Forms, you must import the `FormsModule` from `@angular/forms` into your standalone component's `imports` array.

```typescript
// src/app/my-template-form/my-template-form.component.ts
import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms'; // <--- Import FormsModule

@Component({
  standalone: true,
  selector: 'app-my-template-form',
  imports: [FormsModule], // <--- Add to imports array
  templateUrl: './my-template-form.component.html',
  styleUrls: ['./my-template-form.component.css']
})
export class MyTemplateFormComponent {
  // Data model for the form
  user = {
    name: '',
    email: '',
    agreedToTerms: false
  };

  onSubmit(form: NgForm): void {
    console.log('Form Submitted!', this.user);
    console.log('Form Status:', form.valid);
  }
}
```

**Note for NgModule-based applications:** In traditional Angular applications using `NgModule`s, you would import `FormsModule` into your `AppModule` or a feature module's `imports` array.

### Core Directives for Template-Driven Forms

#### 1. `ngModel` (Two-Way Data Binding)

*   **What it does:** The `ngModel` directive is the cornerstone of Template-Driven Forms. It provides two-way data binding, synchronizing the value of an input element with a property in your component's data model.
*   **Syntax:** `[(ngModel)]="componentProperty"`

**One-Way `ngModel`:** You can also use `ngModel` for one-way data binding (from component to view) using property binding: `[ngModel]="componentProperty"`. This is useful when you want to display a value but prevent user input from changing the component's model directly.

#### 2. `name` Attribute

*   **Requirement:** Every input element that uses `ngModel` **must** have a `name` attribute. This attribute is used by Angular to register the control within the `ngForm` directive.

#### 3. `ngForm` (Implicitly Created)

*   **What it is:** Angular automatically creates an `NgForm` directive on the `<form>` tag. This directive represents the entire form and tracks the state of all its controls.
*   You can get a reference to this `NgForm` instance using a template reference variable (e.g., `#myForm="ngForm"`).

### Example: Simple Registration Form

Let's create a basic registration form using Template-Driven Forms.

**Component (`src/app/registration-td/registration-td.component.ts`):**

```typescript
import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms';

@Component({
  standalone: true,
  selector: 'app-registration-td',
  imports: [FormsModule],
  templateUrl: './registration-td.component.html',
  styleUrls: ['./registration-td.component.css']
})
export class RegistrationTdComponent {
  user = {
    username: '',
    email: '',
    password: ''
  };

  onSubmit(form: NgForm): void {
    if (form.valid) {
      console.log('Form Submitted Successfully!', this.user);
      // Here you would typically send this.user data to a backend service
    } else {
      console.log('Form is invalid.');
    }
  }
}
```

**Template (`src/app/registration-td/registration-td.component.html`):**

```html
<form #registrationForm="ngForm" (ngSubmit)="onSubmit(registrationForm)">
  <div>
    <label for="username">Username:</label>
    <input
      type="text"
      id="username"
      name="username"
      [(ngModel)]="user.username"
      required
      minlength="3"
      #usernameControl="ngModel" <!-- Template reference variable for the control -->
    >
    @if (usernameControl.invalid && (usernameControl.touched || usernameControl.dirty)) { <!-- Note: @if is Angular 17+ syntax. For older versions, use *ngIf -->
      <div class="error-message" aria-live="polite" aria-atomic="true">
        @if (usernameControl.errors?.['required']) {
          <p id="username-required-error">Username is required.</p>
        }
        @if (usernameControl.errors?.['minlength']) {
          <p id="username-minlength-error">Username must be at least 3 characters.</p>
        }
      </div>
    }
  </div>

  <div>
    <label for="email">Email:</label>
    <input
      type="email"
      id="email"
      name="email"
      [(ngModel)]="user.email"
      required
      email
      #emailControl="ngModel"
      [attr.aria-invalid]="emailControl.invalid && (emailControl.touched || emailControl.dirty)"
      [attr.aria-describedby]="(emailControl.invalid && (emailControl.touched || emailControl.dirty)) ? 'email-required-error email-email-error' : null"
    >
    @if (emailControl.invalid && (emailControl.touched || emailControl.dirty)) { <!-- Note: @if is Angular 17+ syntax. For older versions, use *ngIf -->
      <div class="error-message" aria-live="polite" aria-atomic="true">
        @if (emailControl.errors?.['required']) {
          <p id="email-required-error">Email is required.</p>
        }
        @if (emailControl.errors?.['email']) {
          <p id="email-email-error">Please enter a valid email address.</p>
        }
      </div>
    }
  </div>

  <div>
    <label for="password">Password:</label>
    <input
      type="password"
      id="password"
      name="password"
      [(ngModel)]="user.password"
      required
      minlength="6"
      #passwordControl="ngModel"
      [attr.aria-invalid]="passwordControl.invalid && (passwordControl.touched || passwordControl.dirty)"
      [attr.aria-describedby]="(passwordControl.invalid && (passwordControl.touched || passwordControl.dirty)) ? 'password-required-error password-minlength-error' : null"
    >
    @if (passwordControl.invalid && (passwordControl.touched || passwordControl.dirty)) { <!-- Note: @if is Angular 17+ syntax. For older versions, use *ngIf -->
      <div class="error-message" aria-live="polite" aria-atomic="true">
        @if (passwordControl.errors?.['required']) {
          <p id="password-required-error">Password is required.</p>
        }
        @if (passwordControl.errors?.['minlength']) {
          <p id="password-minlength-error">Password must be at least 6 characters.</p>
        }
      </div>
    }
  </div>

  <button type="submit" [disabled]="registrationForm.invalid">Register</button>
</form>
```

**Explanation:**

*   `#registrationForm="ngForm"`: Creates a template reference variable `registrationForm` that refers to the `NgForm` directive on the `<form>` element. This allows us to access the form's overall state (e.g., `registrationForm.valid`).
*   `#usernameControl="ngModel"`: Similarly, creates a template reference variable for each `ngModel` instance, allowing access to individual control states (e.g., `usernameControl.invalid`, `usernameControl.errors`).
*   `required`, `minlength`, `email`: These are standard HTML5 validation attributes. When used with `ngModel`, Angular automatically creates corresponding validators and updates the control's `errors` property.
*   `@if (control.invalid && (control.touched || control.dirty))`: This common pattern ensures that error messages are only shown after the user has interacted with the field or changed its value.

**Accessibility for Error Messages:** For improved accessibility, especially for screen reader users, ensure that error messages are programmatically associated with their respective input fields using `aria-describedby`. Also, consider using `aria-live` regions for dynamic error messages that appear without user interaction. (See [Module 12.3: Accessibility (a11y)](../12-security-i18n-a11y/12.3-accessibility.md) for more details).

### Accessing Form State

Both the `NgForm` instance and individual `ngModel` controls expose properties like `valid`, `invalid`, `touched`, `dirty`, and `errors`. You can use these to dynamically style inputs or display error messages.

```html
<!-- Apply a class based on validation state -->
<input [class.is-invalid]="usernameControl.invalid && usernameControl.touched">

<!-- Disable button if form is invalid -->
<button [disabled]="registrationForm.invalid">Submit</button>
```

While Template-Driven Forms offer a quick way to build simple forms, their limitations become apparent with increasing complexity. For most real-world Angular applications, Reactive Forms provide a more robust, scalable, and testable solution. (See [Module 6.2: Reactive Forms: `FormControl` & `FormGroup`](./6.2-reactive-forms-basics.md) for a detailed dive into Reactive Forms).

---

### Hands-on Exercise: Build a Login Form (Template-Driven)

1.  **Create a `LoginComponent`** using the CLI.
2.  **Build the form model:** Create a `user` object in your component class with `email` and `password` properties.
3.  **Create the HTML template:**
    *   Add a `<form>` tag and bind it to your form model using `ngForm`.
    *   Add `email` and `password` input fields, each with `name` and `[(ngModel)]`.
    *   Add a `submit` button.
4.  **Add Validation:**
    *   Make both fields `required`.
    *   Add `email` validation to the email field.
    *   Add `minlength="8"` validation to the password field.
5.  **Display Validation Messages:**
    *   Show specific error messages for each validation rule (e.g., "Email is required," "Please enter a valid email," "Password must be at least 8 characters").
    *   Ensure error messages only appear after the user has touched the input field.
6.  **Handle Submission:**
    *   Disable the submit button if the form is invalid.
    *   When the form is submitted and valid, log the form's value to the console.

**Note:** This exercise is specifically designed to reinforce the concepts of Template-Driven Forms. Ensure all form logic and validation are handled directly within the template using `ngModel` and `ngForm` directives.

---

**End of Module 6.**

**Previous:** [6.4 Form Validation](./6.4-form-validation.md)

**Next:** [07-http-client](../07-http-client)
