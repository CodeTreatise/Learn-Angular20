# Module 6.4: Form Validation

**Objective:** By the end of this module, you will be able to:
- **Implement** robust form validation in Angular Reactive Forms using built-in, custom, and asynchronous validators.
- **Effectively display** validation messages to the user.
- **Understand** best practices for form validation and user feedback.

---

### The Importance of Validation

Form validation is crucial for:

*   **Data Integrity:** Ensuring that the data submitted by the user meets the application's requirements.
*   **User Experience:** Providing immediate feedback to users about incorrect input, guiding them to correct errors before submission.
*   **Security:** Preventing malicious or malformed data from reaching the backend.

**Note on Accessibility:** When displaying validation messages, ensure they are clearly associated with their respective input fields using ARIA attributes (e.g., `aria-describedby`) and that screen readers can announce dynamic error messages using ARIA live regions (`aria-live="polite"`).

```mermaid
%%{init: {'theme':'neutral'}}%%
graph TD
    A[User Input] --> B{FormControl};
    B -- applies --> C[Validators];
    C -- result --> D{Control State (valid/invalid, errors)};
    D -- informs --> E[Template (display messages)];
```
**Alt text:** Diagram illustrating the form validation flow: User input goes to a FormControl, which applies Validators. The validation result updates the Control State (valid/invalid, errors), which then informs the Template to display messages.

**Text Summary of Validation Flow:**

User input is processed by a `FormControl`, which applies defined `Validators`. The result updates the `Control State` (valid/invalid, errors), which then informs the `Template` to display appropriate messages to the user.

### 1. Built-in Validators

Angular provides a set of common, synchronous validators in the `Validators` class. You apply these when you instantiate a `FormControl` or `FormGroup`.

**Syntax:** `new FormControl(initialValue, [Validators.validator1, Validators.validator2])`

**Summary of Common Built-in Validators:**

| Validator                 | Description                                                                 |
| :------------------------ | :-------------------------------------------------------------------------- |
| `Validators.required`     | Ensures the control has a non-empty value.                                  |
| `Validators.minlength(len)` | Requires the control's value to have a minimum length.                      |
| `Validators.maxlength(len)` | Requires the control's value to have a maximum length.                      |
| `Validators.pattern(regex)` | Requires the control's value to match a specific regular expression.        |
| `Validators.email`        | Requires the control's value to be a valid email format.                    |
| `Validators.min(value)`   | Requires the control's numeric value to be `>=` a specified minimum.        |
| `Validators.max(value)`   | Requires the control's numeric value to be `<=` a specified maximum.        |

**Example:**

```typescript
import { FormControl, FormGroup, Validators } from '@angular/forms';

export class UserFormComponent {
  userForm = new FormGroup({
    username: new FormControl('', [
      Validators.required,
      Validators.minLength(5),
      Validators.maxLength(20),
      Validators.pattern(/^[a-zA-Z0-9]+$/) // Alphanumeric only
    ]),
    email: new FormControl('', [
      Validators.required,
      Validators.email
    ]),
    age: new FormControl(null, [
      Validators.min(18),
      Validators.max(99)
    ]),
    password: new FormControl('', Validators.required)
  });
}
```

**Tip on Combining Validators:** You can combine multiple validators by passing them as an array to the `FormControl` constructor. Angular will run all of them, and the control will be invalid if any validator returns an error.

### 2. Displaying Validation Messages

Angular tracks the validation state of each `FormControl` and `FormGroup`. You can use these states to conditionally display error messages.

**Key Control States:**

*   `control.invalid`: `true` if the control's value is invalid.
*   `control.valid`: `true` if the control's value is valid.
*   `control.touched`: `true` if the user has interacted with the control (e.g., blurred out of it).
*   `control.untouched`: `true` if the user has not yet interacted with the control.
*   `control.dirty`: `true` if the user has changed the value of the control.
*   `control.pristine`: `true` if the user has not changed the value of the control.
*   `control.errors`: An object containing the validation errors, where keys are validator names (e.g., `required`, `minlength`) and values are error details.

**Best Practice:** Display error messages only when the control is `invalid` AND `touched` or `dirty`. This prevents showing errors before the user has even had a chance to type.

**Note on ARIA Live Regions:** For dynamic error messages that appear or disappear, consider using `aria-live="polite"` on the error message container. This will instruct screen readers to announce the changes without interrupting the user's current task.

**Example Template (`.html`):**

```html
<form [formGroup]="userForm" (ngSubmit)="onSubmit()">
  <div>
    <label for="username">Username:</label>
    <input id="username" type="text" formControlName="username">
    @if (userForm.get('username')?.invalid && (userForm.get('username')?.touched || userForm.get('username')?.dirty)) {
      <div class="error-message" aria-live="polite">
        @if (userForm.get('username')?.errors?.['required']) {
          Username is required.
        }
        @if (userForm.get('username')?.errors?.['minlength']) {
          Username must be at least 5 characters long.
        }
        @if (userForm.get('username')?.errors?.['pattern']) {
          Username can only contain letters and numbers.
        }
      </div>
    }
  </div>

  <div>
    <label for="email">Email:</label>
    <input id="email" type="email" formControlName="email">
    @if (userForm.get('email')?.invalid && (userForm.get('email')?.touched || userForm.get('email')?.dirty)) {
      <div class="error-message" aria-live="polite">
        @if (userForm.get('email')?.errors?.['required']) {
          Email is required.
        }
        @if (userForm.get('email')?.errors?.['email']) {
          Please enter a valid email address.
        }
      </div>
    }
  </div>

  <button type="submit" [disabled]="userForm.invalid">Submit</button>
</form>
```

**Tip on Multiple Error Messages:** For a single field with multiple validation errors, you can prioritize which message to show (e.g., `required` before `minlength`) or display all relevant messages. The `@if` blocks in the example demonstrate how to check for specific errors.

**Note on Localization:** For international applications, consider using an internationalization (i18n) library to manage and display validation messages in multiple languages. (See [Module 12.2: Internationalization (i18n)](../../12-security-i18n-a11y/12.2-internationalization.md) for more details).

### 3. Custom Validators

When built-in validators aren't enough, you can create your own custom validator functions. A validator function takes a `FormControl` (or `AbstractControl`) as an argument and returns either `null` (if valid) or an object containing the validation error (if invalid).

**Example: Password Match Validator**

This validator ensures that two password fields have the same value.

```typescript
// src/app/shared/validators/password-match.validator.ts
import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';

export function passwordMatchValidator(): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const password = control.get('password');
    const confirmPassword = control.get('confirmPassword');

    // If either control doesn't exist or hasn't been touched, return null
    if (!password || !confirmPassword) {
      return null;
    }

    // If confirmPassword is valid, but doesn't match password, set error on confirmPassword
    if (confirmPassword.errors && !confirmPassword.errors['passwordMismatch']) {
      return null; // Don't override other errors
    }

    if (password.value !== confirmPassword.value) {
      // Set error on the confirmPassword control
      confirmPassword.setErrors({ passwordMismatch: true });
      return { passwordMismatch: true };
    } else {
      // If they match, clear the error
      confirmPassword.setErrors(null);
      return null;
    }
  };
}
```

**Applying a Custom Validator to a `FormGroup`:**

Custom validators that compare multiple controls (like password match) are typically applied to the `FormGroup` that contains those controls.

```typescript
import { FormControl, FormGroup, Validators } from '@angular/forms';
import { passwordMatchValidator } from './shared/validators/password-match.validator';

export class RegistrationFormComponent {
  registrationForm = new FormGroup({
    password: new FormControl('', Validators.required),
    confirmPassword: new FormControl('', Validators.required)
  }, { validators: passwordMatchValidator() }); // Apply to the FormGroup

  // ... template and other methods
}
```

**Tip on Displaying Group-Level Errors:** For validators applied to a `FormGroup` (like `passwordMatchValidator`), you'll need to access the `FormGroup`'s `errors` property and display the message accordingly. You might also want to highlight the individual controls involved in the group-level error.

**Tip on Unit Testing Custom Validators:** Custom validators are pure functions, making them very easy to unit test. You can simply call the validator function with a mock `AbstractControl` and assert the returned `ValidationErrors` object.

### 4. Asynchronous Validators

Asynchronous validators are used for validation that requires an external call, such as checking if a username is already taken by querying a database.

*   They return a `Promise<ValidationErrors | null>` or `Observable<ValidationErrors | null>`.
*   Angular sets the control's status to `PENDING` while the async validation is in progress.

**Example: Unique Username Validator**

```typescript
// src/app/shared/validators/unique-username.validator.ts
import { AbstractControl, ValidationErrors, AsyncValidatorFn } from '@angular/forms';
import { Observable, of } from 'rxjs';
import { map, catchError, debounceTime, take } from 'rxjs/operators';
import { UserService } from '../user.service'; // Assume a service to check username

export function uniqueUsernameValidator(userService: UserService): AsyncValidatorFn {
  return (control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null> => {
    if (!control.value) {
      return of(null); // If no value, don't validate
    }

    return userService.checkUsernameExists(control.value).pipe(
      debounceTime(500), // Wait for user to stop typing
      take(1), // Take only the first emission
      map(isTaken => (isTaken ? { uniqueUsername: true } : null)),
      catchError(() => of(null)) // Handle API errors gracefully
    );
  };
}
```

**Applying an Async Validator:**

```typescript
import { FormControl, FormGroup, Validators } from '@angular/forms';
import { uniqueUsernameValidator } from './shared/validators/unique-username.validator';
import { UserService } from './user.service';

export class RegistrationFormComponent {
  registrationForm: FormGroup;

  constructor(private userService: UserService) {
    this.registrationForm = new FormGroup({
      username: new FormControl('', [
        Validators.required,
        Validators.minLength(5)
      ], [
        uniqueUsernameValidator(this.userService) // Async validators go here
      ]),
      // ... other controls
    });
  }
}
```

**Tip on Handling API Errors Gracefully:** In asynchronous validators, it's good practice to catch errors from the API call and return `of(null)` or a specific error object. This prevents the form from getting stuck in a `PENDING` state or crashing due to network issues.

Form validation is a critical aspect of user experience and data integrity. By combining built-in, custom, and asynchronous validators, you can create highly robust and user-friendly forms in your Angular applications.

---

**Previous:** [6.3 Reactive Forms: `FormBuilder` & `FormArray`](./6.3-form-builder-form-array.md)

**Next:** [6.5 Template-Driven Forms](./6.5-template-driven-forms.md)
