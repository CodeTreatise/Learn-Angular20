# Module 13.3: Unit Testing Services and Pipes

**Objective:** To learn how to write effective unit tests for Angular services and pipes, focusing on isolating their logic and mocking any dependencies.

---

### 1. Unit Testing Services

Services in Angular are typically plain TypeScript classes that encapsulate business logic, data access, or shared functionality. Unit testing services is generally straightforward because they don't have templates or direct DOM interactions.

#### a) Testing a Service Without Dependencies

If a service doesn't depend on other services, you can simply instantiate it and test its methods.

**Example: `CalculatorService`**

```typescript
// src/app/calculator.service.ts
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class CalculatorService {
  add(a: number, b: number): number {
    return a + b;
  }

  subtract(a: number, b: number): number {
    return a - b;
  }
}
```

**Test File (`src/app/calculator.service.spec.ts`):**

```typescript
import { CalculatorService } from './calculator.service';

describe('CalculatorService', () => {
  let service: CalculatorService;

  beforeEach(() => {
    service = new CalculatorService(); // Directly instantiate
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });

  it('should add two numbers', () => {
    expect(service.add(2, 3)).toBe(5);
  });

  it('should subtract two numbers', () => {
    expect(service.subtract(5, 2)).toBe(3);
  });
});
```

#### b) Testing a Service With Dependencies

If a service depends on other services (e.g., `HttpClient`), you should mock those dependencies to ensure you are only testing the logic of the service itself.

**Example: `UserService` with `HttpClient` dependency**

```typescript
// src/app/user.service.ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, of } from 'rxjs';

interface User { id: number; name: string; email: string; }

@Injectable({
  providedIn: 'root'
})
export class UserService {
  private apiUrl = 'https://api.example.com/users';

  constructor(private http: HttpClient) { }

  getUsers(): Observable<User[]> {
    return this.http.get<User[]>(this.apiUrl);
  }

  getUserById(id: number): Observable<User> {
    return this.http.get<User>(`${this.apiUrl}/${id}`);
  }
}
```

**Test File (`src/app/user.service.spec.ts`):**

```typescript
import { TestBed } from '@angular/core/testing';
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';

import { UserService } from './user.service';

describe('UserService', () => {
  let service: UserService;
  let httpTestingController: HttpTestingController; // Mock HTTP backend

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule], // Import for mocking HTTP
      providers: [UserService]
    });

    service = TestBed.inject(UserService); // Get instance from TestBed
    httpTestingController = TestBed.inject(HttpTestingController); // Get mock backend
  });

  afterEach(() => {
    // Verify that no outstanding requests are pending
    httpTestingController.verify();
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });

  it('should retrieve users from the API via GET', () => {
    const dummyUsers = [
      { id: 1, name: 'John Doe', email: 'john@example.com' },
      { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
    ];

    service.getUsers().subscribe(users => {
      expect(users.length).toBe(2);
      expect(users).toEqual(dummyUsers);
    });

    // Expect a GET request to the users API
    const req = httpTestingController.expectOne('https://api.example.com/users');
    expect(req.request.method).toBe('GET');

    // Respond with the dummy data
    req.flush(dummyUsers);
  });

  it('should retrieve a user by ID from the API via GET', () => {
    const dummyUser = { id: 1, name: 'John Doe', email: 'john@example.com' };
    const userId = 1;

    service.getUserById(userId).subscribe(user => {
      expect(user).toEqual(dummyUser);
    });

    const req = httpTestingController.expectOne(`https://api.example.com/users/${userId}`);
    expect(req.request.method).toBe('GET');
    req.flush(dummyUser);
  });
});
```

**Key Elements for Testing Services with Dependencies:**

*   **`TestBed.configureTestingModule()`:** Used to set up a testing module. You provide the service under test and any mocks for its dependencies.
*   **`HttpClientTestingModule`:** This module from `@angular/common/http/testing` replaces the real `HttpClient` with a mock version, allowing you to control HTTP responses in your tests.
*   **`HttpTestingController`:** Injected to control the mock HTTP backend. You use it to `expectOne()` (or `expectMany()`) requests and `flush()` them with mock data or errors.
*   **`TestBed.inject()`:** The preferred way to get instances of services from the `TestBed`.

--- 

### 2. Unit Testing Pipes

Pipes are pure functions (by default) that transform data. Testing them is usually very simple.

#### a) Testing a Pure Pipe

**Example: `PhoneNumberPipe`**

```typescript
// src/app/phone-number.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  standalone: true,
  name: 'phoneNumber'
})
export class PhoneNumberPipe implements PipeTransform {
  transform(value: string | number, countryCode?: string): string {
    if (!value) return '';

    let phoneStr = value.toString().replace(/\D/g, '');

    if (countryCode === 'US') {
      if (phoneStr.length === 10) {
        return `(${phoneStr.substring(0, 3)}) ${phoneStr.substring(3, 6)}-${phoneStr.substring(6)}`;
      }
    } else if (phoneStr.length >= 10) {
      return `+${phoneStr.substring(0, 2)} ${phoneStr.substring(2, 5)} ${phoneStr.substring(5, 8)} ${phoneStr.substring(8)}`;
    }

    return phoneStr;
  }
}
```

**Test File (`src/app/phone-number.pipe.spec.ts`):**

```typescript
import { PhoneNumberPipe } from './phone-number.pipe';

describe('PhoneNumberPipe', () => {
  let pipe: PhoneNumberPipe;

  beforeEach(() => {
    pipe = new PhoneNumberPipe(); // Directly instantiate the pipe
  });

  it('should be created', () => {
    expect(pipe).toBeTruthy();
  });

  it('should format a 10-digit US number', () => {
    expect(pipe.transform('1234567890', 'US')).toBe('(123) 456-7890');
  });

  it('should format an international number', () => {
    expect(pipe.transform('919876543210')).toBe('+91 987 654 3210');
  });

  it('should return empty string for null or undefined input', () => {
    expect(pipe.transform(null)).toBe('');
    expect(pipe.transform(undefined)).toBe('');
  });

  it('should return original string if not 10 digits and no country code', () => {
    expect(pipe.transform('123')).toBe('123');
  });
});
```

#### b) Testing an Impure Pipe (Caution)

If you have an impure pipe (`pure: false`), it might have dependencies or internal state. You would test it similarly to a service, potentially using `TestBed` if it has injected dependencies.

Unit testing services and pipes is crucial for ensuring the correctness of your application's business logic and data transformations. By isolating these units, you can write fast, reliable, and maintainable tests.

---

**Previous:** [13.2 Unit Testing Components](./13.2-unit-testing-components.md)

**Next:** [13.4 End-to-End (E2E) Testing with Cypress](./13.4-e2e-testing-cypress.md)
