# Module 9.4: Effects

**Objective:** To understand how to use the `effect()` function in Angular Signals to perform side effects that react to changes in one or more signals.

---

### The Need for Side Effects

While signals are great for managing reactive state and derived values, sometimes you need to perform actions that are *not* directly related to rendering the UI. These are called **side effects**. Examples include:

*   Logging a message to the console when a signal changes.
*   Synchronizing data with `localStorage`.
*   Manually updating a DOM element (e.g., focusing an input).
*   Sending analytics events.
*   Making an HTTP request (though often better handled with RxJS).

`effect()` provides a dedicated mechanism for running such side effects in response to signal changes.

### What are Effects?

An effect is a function that runs whenever one or more of its dependent signals change. It's designed for logic that needs to run *because* a signal changed, but doesn't directly produce a new signal value.

```mermaid
%%{init: {'theme':'neutral'}}%%
graph TD
    A[Signal A] --> C(Effect);
    B[Signal B] --> C;
    C -- performs --> D[Side Effect (e.g., console.log, localStorage, API call)];

    subgraph Reactivity Flow
        A -- changes --> C;
        B -- changes --> C;
    end
```
**Alt text:** Diagram illustrating how an Effect reacts to changes in Signal A and Signal B, performing a side effect such as logging, updating localStorage, or making an API call.

#### Key Characteristics of Effects:

*   **Side Effects Only:** Effects are meant for side effects. They do not return a value and cannot be used to create new signals or computed signals.
*   **Automatic Dependency Tracking:** Like `computed()`, `effect()` automatically tracks which signals it reads within its function. It will re-run whenever any of those dependencies change.
*   **Runs at Least Once:** An effect always runs at least once when it's created.
*   **Cleanup Function:** An effect can optionally return a cleanup function, which will be executed before the effect re-runs or when the effect is destroyed.

--- 

### Creating an Effect

Effects are created using the `effect()` function from `@angular/core/rxjs-interop` (or `@angular/core` in newer versions). It takes a function as its first argument, which contains the side effect logic.

**Syntax:**

```typescript
import { effect } from '@angular/core';

// Inside a component or service constructor, or ngOnInit
constructor() {
  effect(() => {
    // Side effect logic here
    console.log('Signal changed!');
  });
}
```

**Important:** Effects should typically be created within the constructor of a component or service, or within `ngOnInit`.

#### Example 1: Logging Signal Changes

```typescript
import { Component, signal, effect } from '@angular/core';

@Component({
  standalone: true,
  selector: 'app-logging-effect-demo',
  template: `
    <p>Message: {{ message() }}</p>
    <button (click)="changeMessage()">Change Message</button>
  `
})
export class LoggingEffectDemoComponent {
  message = signal('Hello World');

  constructor() {
    // This effect will run whenever `message` signal changes
    effect(() => {
      console.log(`Message signal changed to: ${this.message()}`);
    });
  }

  changeMessage(): void {
    this.message.set('Angular Signals are awesome!');
  }
}
```

#### Example 2: Synchronizing with `localStorage`

```typescript
import { Component, signal, effect } from '@angular/core';

@Component({
  standalone: true,
  selector: 'app-local-storage-effect-demo',
  template: `
    <p>User Preference: {{ theme() }}</p>
    <button (click)="toggleTheme()">Toggle Theme</button>
  `
})
export class LocalStorageEffectDemoComponent {
  // Initialize signal from localStorage or default
  theme = signal(localStorage.getItem('appTheme') || 'light');

  constructor() {
    // This effect will run whenever `theme` signal changes
    effect(() => {
      console.log(`Saving theme to localStorage: ${this.theme()}`);
      localStorage.setItem('appTheme', this.theme());
    });
  }

  toggleTheme(): void {
    this.theme.update(currentTheme => (currentTheme === 'light' ? 'dark' : 'light'));
  }
}
```

#### Example 3: Cleanup Function

An effect can return a cleanup function. This function is executed just before the effect re-runs (due to a dependency change) or when the effect is destroyed.

```typescript
import { Component, signal, effect } from '@angular/core';

@Component({
  standalone: true,
  selector: 'app-cleanup-effect-demo',
  template: `
    <p>Value: {{ value() }}</p>
    <button (click)="increment()">Increment</button>
  `
})
export class CleanupEffectDemoComponent {
  value = signal(0);

  constructor() {
    effect(() => {
      const currentValue = this.value();
      console.log(`Effect running for value: ${currentValue}`);

      // Return a cleanup function
      return () => {
        console.log(`Cleaning up effect for value: ${currentValue}`);
      };
    });
  }

  increment(): void {
    this.value.update(v => v + 1);
  }
}
```

### When to Use Effects

*   **Synchronizing with External Systems:** `localStorage`, `sessionStorage`, Web APIs (e.g., `document.title`), analytics services.
*   **Manual DOM Manipulation:** When you need to directly interact with the DOM outside of Angular's template rendering (use sparingly).
*   **Logging and Debugging:** As a simple way to observe signal changes.

### When NOT to Use Effects

*   **For Data Transformation:** Use `computed()` instead. Effects do not return values.
*   **For State Management:** Effects should not directly modify other signals. If a signal needs to change based on another signal, use `computed()` or a service that orchestrates signal updates.
*   **For Asynchronous Data Fetching (often):** While possible, for complex data fetching scenarios (e.g., HTTP requests with cancellation, retries, debouncing), RxJS Observables and `HttpClient` are generally more suitable and powerful.

Effects complete the reactivity story for Angular Signals, providing a dedicated and controlled way to perform side effects in response to state changes. They are a powerful tool when used appropriately.

---

**Previous:** [9.3 Computed Signals](./9.3-computed-signals.md)

**Next:** [9.5 Interoperability with RxJS](./9.5-rxjs-interop.md)
