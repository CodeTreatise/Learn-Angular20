# Module 10.4: Change Detection Strategy: OnPush

**Objective:** To understand Angular's change detection mechanism and how to optimize application performance by leveraging the `OnPush` change detection strategy.

---

### The Heart of Angular: Change Detection

Angular applications are dynamic. When data changes (e.g., a user types into an input, an HTTP request returns data, a timer fires), Angular needs to update the DOM to reflect these changes. This process is called **Change Detection**.

By default, Angular uses a strategy called `Default` (or `CheckAlways`). This means that after every asynchronous event (like a user interaction, HTTP response, or `setTimeout`), Angular will check *every* component in the component tree from top to bottom to see if any data has changed. If a component's data has changed, its view (and potentially its child views) will be re-rendered.

```mermaid
graph TD
    A[Asynchronous Event (Click, HTTP, Timer)] --> B{Zone.js (patches APIs)};
    B --> C[Angular Change Detection Triggered];
    C --> D[Traverse Component Tree (Default: Check All)];
    D --> E{Check Component Data};
    E -- Data Changed? --> F[Update DOM];
```

**While convenient, the `Default` strategy can become a performance bottleneck in large applications with many components, as checking every component can be expensive.**

--- 

### Optimizing with `OnPush` Change Detection Strategy

Angular provides an alternative change detection strategy called `OnPush`. When a component is set to `OnPush`, Angular will only run change detection for that component (and its subtree) under specific conditions, making the process much more efficient.

#### How `OnPush` Works

With `OnPush` strategy, Angular will only check a component for changes if:

1.  **All `@Input()` properties have changed (by reference).** If an input is an object and only its internal properties change (but the object reference remains the same), `OnPush` will *not* detect a change.
2.  **An event originated from the component or one of its children.** This includes events from `HostListener` or template event bindings.
3.  **An Observable bound to the template using the `async` pipe emits a new value.** The `async` pipe automatically marks the component for check.
4.  **Change detection is explicitly triggered** (e.g., using `ChangeDetectorRef.detectChanges()` or `ChangeDetectorRef.markForCheck()`).

```mermaid
graph TD
    A[Asynchronous Event] --> B{Zone.js};
    B --> C[Angular Change Detection Triggered];
    C --> D[Traverse Component Tree (OnPush: Check Conditionally)];
    D -- Input Reference Changed? --> E[Check Component Data];
    D -- Event Originated Here? --> E;
    D -- Async Pipe Emitted? --> E;
    D -- Explicitly Marked? --> E;
    E -- Data Changed? --> F[Update DOM];
```

#### Implementing `OnPush`

You set the `changeDetection` property in the `@Component` decorator.

```typescript
import { Component, ChangeDetectionStrategy, Input } from '@angular/core';

@Component({
  standalone: true,
  selector: 'app-on-push-child',
  template: `
    <h3>OnPush Child Component</h3>
    <p>Value: {{ data.value }}</p>
    <p>Timestamp: {{ data.timestamp }}</p>
    <button (click)="onClick()">Click Me (Inside OnPush)</button>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush // <--- Set OnPush strategy
})
export class OnPushChildComponent {
  @Input() data: { value: number; timestamp: string } = { value: 0, timestamp: '' };

  onClick(): void {
    console.log('Button clicked inside OnPush component.');
    // This event originates from within the component, so change detection will run.
  }
}
```

#### Example: Demonstrating `OnPush` Behavior

Let's create a parent component that passes data to an `OnPush` child component.

**Parent Component (`app.component.ts`):**

```typescript
import { Component, OnInit } from '@angular/core';
import { OnPushChildComponent } from './on-push-child/on-push-child.component';

@Component({
  standalone: true,
  selector: 'app-root',
  imports: [OnPushChildComponent],
  template: `
    <h1>Parent Component (Default Change Detection)</h1>
    <button (click)="updateData()">Update Data (Mutate Object)</button>
    <button (click)="replaceData()">Replace Data (New Object)</button>
    <button (click)="triggerParentChange()">Trigger Parent Change</button>

    <app-on-push-child [data]="childData"></app-on-push-child>
  `
})
export class AppComponent implements OnInit {
  childData = { value: 0, timestamp: new Date().toLocaleTimeString() };

  ngOnInit(): void {
    setInterval(() => {
      // This will trigger change detection in the parent, but NOT in the OnPush child
      // unless its input reference changes or an event originates from it.
      console.log('Parent interval tick');
    }, 2000);
  }

  updateData(): void {
    // This MUTATES the object. OnPush child will NOT detect this change.
    this.childData.value++;
    this.childData.timestamp = new Date().toLocaleTimeString();
    console.log('Data MUTATED:', this.childData);
  }

  replaceData(): void {
    // This creates a NEW object reference. OnPush child WILL detect this change.
    this.childData = { value: this.childData.value + 1, timestamp: new Date().toLocaleTimeString() };
    console.log('Data REPLACED:', this.childData);
  }

  triggerParentChange(): void {
    // This will trigger change detection in the parent, but not necessarily the OnPush child
    // unless its input reference changes or an event originates from it.
    console.log('Parent change triggered.');
  }
}
```

**Observations:**

*   When `updateData()` is called (mutating `childData`), the `OnPushChildComponent`'s view will *not* update, because the `data` input's reference hasn't changed.
*   When `replaceData()` is called (creating a new `childData` object), the `OnPushChildComponent`'s view *will* update, because the `data` input's reference has changed.
*   The `onClick()` method inside `OnPushChildComponent` will always trigger change detection for itself and its children, regardless of input changes.

### Explicitly Triggering Change Detection

If you are using `OnPush` and need to force a change detection cycle for a component (e.g., after an asynchronous operation that doesn't involve an `async` pipe or input change), you can use `ChangeDetectorRef`.

```typescript
import { Component, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';

@Component({
  standalone: true,
  selector: 'app-manual-cd',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `<p>Count: {{ count }}</p><button (click)="increment()">Increment</button>`
})
export class ManualCdComponent {
  count: number = 0;

  constructor(private cdr: ChangeDetectorRef) { }

  increment(): void {
    this.count++;
    // If count was updated by an external source (e.g., a service that doesn't use signals)
    // and no event originated from this component, you might need to manually mark for check.
    this.cdr.detectChanges(); // Forces a check of this component and its children
    // OR
    // this.cdr.markForCheck(); // Marks this component for check during the next change detection cycle
  }
}
```

### When to Use `OnPush`

*   **Performance Optimization:** For large applications with many components, `OnPush` can significantly reduce the number of change detection cycles, leading to better performance.
*   **Predictable Behavior:** Encourages immutable data patterns, making your application's state changes more predictable and easier to debug.
*   **Default for New Projects:** With the rise of Signals, `OnPush` is becoming the de facto standard and is often the default for new components generated by the CLI.

**Best Practice:** Aim to use `OnPush` for most of your components. This forces you to think about data flow and immutability, which leads to more robust and performant applications. Combine it with Signals and the `async` pipe for the most efficient change detection.

---

### Hands-on Exercise: Optimize a User List with OnPush

1.  **Create a `UserListComponent`** (parent) and a `UserCardComponent` (child).
2.  **In `UserListComponent`:**
    *   Maintain an array of user objects (e.g., `{ id: number, name: string, email: string }`).
    *   Pass each user object to `UserCardComponent` using an `@Input()`.
    *   Add a button to `UserListComponent` that, when clicked, *mutates* one of the user objects in the array (e.g., changes the email of a user).
    *   Add another button that, when clicked, *replaces* the entire user array with a new array (even if the content is the same).
3.  **In `UserCardComponent`:**
    *   Set its `changeDetection` strategy to `ChangeDetectionStrategy.OnPush`.

    *   Display the user's name and email.
    *   Add a `console.log` inside `ngOnChanges` or a simple getter that logs when it's accessed, to observe when change detection runs for this component.
4.  **Observe the behavior:**
    *   When you mutate a user object in the parent, notice that the `UserCardComponent` (with `OnPush`) does not update its view or log a change, because the input reference didn't change.
    *   When you replace the entire user array, notice that the `UserCardComponent` *does* update and logs a change, because the input reference changed.
    *   Add a button inside `UserCardComponent` that triggers an internal change (e.g., toggles a local boolean). Observe that this *does* trigger change detection for `UserCardComponent`.

---

**Previous:** [10.3 Custom Directives and Pipes](./10.3-custom-directives-pipes.md)

**Next:** [10.5 Performance Optimization Techniques](./10.5-performance-optimization.md)