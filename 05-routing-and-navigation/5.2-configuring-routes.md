# Module 5.2: Configuring Routes

**Objective:** By the end of this module, you will be able to define routes in an Angular application, associate them with components, and use the `RouterOutlet` and `routerLink` directives for declarative navigation.

---

### The `Routes` Array: Defining Your Application Paths

At the heart of Angular routing is the `Routes` array. This array contains a collection of `Route` objects, where each object maps a URL path to a component.

```mermaid
%%{init: {'theme':'neutral'}}%%
graph TD
    A[URL Path (e.g., /products)] --> B{Route Configuration};
    B -- maps to --> C[Component (e.g., ProductListComponent)];
    C -- renders into --> D[RouterOutlet];
```
**Alt text:** Diagram showing a URL path mapping to a route configuration, which maps to a component, which then renders into a RouterOutlet.

**Text Summary of Route Mapping:**

A URL path is mapped to a specific route configuration, which in turn maps to a component. This component is then rendered into the `RouterOutlet` placeholder in the HTML.

**Basic `Route` Object Structure:**

```typescript
import { Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { AboutComponent } from './about/about.component';
import { ContactComponent } from './contact/contact.component';

export const routes: Routes = [
  {
    path: '', // The URL path (empty string for the default/root path)
    component: HomeComponent // The component to render when this path is active
  },
  {
    path: 'about',
    component: AboutComponent
  },
  {
    path: 'contact',
    component: ContactComponent
  },
  {
    path: '**', // Wildcard route: matches any path not previously matched
    component: NotFoundComponent // A component to display for 404 errors
  }
];
```

**Key `Route` Properties:**

*   **`path: string`**: The URL path segment. Can be:
    *   An empty string (`''`): Represents the default path (e.g., `http://localhost:4200/`).
    *   A specific string (`'about'`): Matches `http://localhost:4200/about`.
    *   A wildcard (`'**'`): Matches any URL not previously matched. Always place this as the *last* route in your configuration. **Important:** The order of routes in the `Routes` array matters. The router uses a first-match wins strategy, so more specific routes should come before less specific ones.
*   **`component: Type<any>`**: The component that Angular should render when this route is active.

**Advanced Route Properties:** The `Route` object has many other properties for advanced scenarios, such as `redirectTo`, `pathMatch`, `children` (for nested routes), `canActivate` (for route guards), `resolve` (for pre-fetching data), and `data` (for arbitrary static data). You can find a comprehensive list in the [Angular Router documentation](https://angular.dev/api/router/Route).

### Providing the Router Configuration

In a standalone Angular application, you provide the router configuration at the application's root level, typically in `src/app/app.config.ts`.

```typescript
// src/app/app.config.ts
import { ApplicationConfig } from '@angular/core';
import { provideRouter } from '@angular/router'; // Import provideRouter

import { routes } from './app.routes'; // Import your routes array

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes) // Provide the router with your defined routes
  ]
};
```

*   **`provideRouter(routes)`**: This function sets up the Angular Router and makes your defined `routes` available throughout the application. It also registers all the necessary router services.

**Tip on Dynamic Route Updates:** For advanced scenarios, routes can be updated dynamically at runtime using `Router.resetConfig()` or by loading feature modules. This is typically used in large, modular applications.

### The `RouterOutlet`: Where Components Are Rendered

The `RouterOutlet` is a directive that acts as a placeholder in your HTML template. Angular dynamically renders the component associated with the active route into this placeholder.

Typically, you place the `RouterOutlet` in your main `AppComponent`'s template, as it's the top-level component that hosts your application's views.

**Accessibility Note:** When content changes dynamically due to routing, it's important to consider accessibility. For screen reader users, you might need to programmatically manage focus to the newly loaded content or use ARIA live regions to announce changes. (See [Module 12.3: Accessibility (a11y)](../12-security-i18n-a11y/12.3-accessibility.md) for more details).

**Example `app.component.html`:**

```html
<header>
  <h1>My Angular App</h1>
  <nav>
    <a routerLink="/">Home</a>
    <a routerLink="/about">About</a>
    <a routerLink="/contact">Contact</a>
  </nav>
</header>

<main>
  <!-- The router will render components here based on the active route -->
  <router-outlet></router-outlet>
</main>

<footer>
  <p>&copy; 2025 My Angular App</p>
</footer>
```

```mermaid
%%{init: {'theme':'neutral'}}%%
graph TD
    A[index.html] --> B(app-root);
    B --> C(app.component.html);
    C --> D(router-outlet);
    D -- renders --> E{HomeComponent (if path is '/')};
    D -- renders --> F{AboutComponent (if path is '/about')};
    D -- renders --> G{ContactComponent (if path is '/contact')};
```
**Alt text:** Diagram illustrating how the index.html hosts the app-root, which contains app.component.html. Inside app.component.html, the router-outlet dynamically renders components like HomeComponent, AboutComponent, or ContactComponent based on the active route.

**Text Summary of RouterOutlet Rendering:**

The `index.html` file contains the `app-root` element, which hosts the `app.component.html` template. Within this template, the `<router-outlet>` directive serves as a dynamic placeholder. Based on the active route, the Angular Router renders the corresponding component (e.g., `HomeComponent`, `AboutComponent`, `ContactComponent`) into this `router-outlet`.

### The `routerLink` Directive: Declarative Navigation

The `routerLink` directive is an attribute directive that allows you to create navigation links in your templates. It's the preferred way to navigate declaratively.

**Syntax:**

```html
<a routerLink="/path/to/route">Link Text</a>
```

**Example with Variables:**

```html
<!-- Navigating to a product detail page using a component property -->
<a [routerLink]="['/products', productId]">View Product Details</a>

<!-- Navigating to a user profile using a component property -->
<a [routerLink]="['/users', currentUser.id]">{{ currentUser.name }} Profile</a>
```

**Why `routerLink` over `href`?**

*   `routerLink` uses the Angular Router to perform client-side navigation, which means no full page reloads.
*   `href` would trigger a full browser page reload, defeating the purpose of an SPA.

**Note on Progressive Enhancement:** For applications that need to function even without JavaScript (e.g., for very old browsers or specific SEO needs), you might consider server-side rendering (SSR) or a hybrid approach. However, for typical Angular SPAs, `routerLink` is the standard.

### Setting Up a Basic Routing Example

Let's put it all together with a simple example.

1.  **Create Components:**
    ```bash
    ng g c home --standalone
    ng g c about --standalone
    ng g c contact --standalone
    ng g c not-found --standalone
    ```

2.  **Define Routes (`src/app/app.routes.ts`):**
    ```typescript
    import { Routes } from '@angular/router';
    import { HomeComponent } from './home/home.component';
    import { AboutComponent } from './about/about.component';
    import { ContactComponent } from './contact/contact.component';
    import { NotFoundComponent } from './not-found/not-found.component';

    export const routes: Routes = [
      { path: '', component: HomeComponent },
      { path: 'about', component: AboutComponent },
      { path: 'contact', component: ContactComponent },
      { path: '**', component: NotFoundComponent } // Wildcard route
    ];
    ```

3.  **Provide Router in `app.config.ts`:**
    ```typescript
    // src/app/app.config.ts
    import { ApplicationConfig } from '@angular/core';
    import { provideRouter } from '@angular/router';
    import { routes } from './app.routes';

    export const appConfig: ApplicationConfig = {
      providers: [
        provideRouter(routes)
      ]
    };
    ```

4.  **Add `RouterOutlet` and `routerLink` in `app.component.html`:**
    ```html
    <!-- src/app/app.component.html -->
    <nav>
      <a routerLink="/">Home</a> |
      <a routerLink="/about">About</a> |
      <a routerLink="/contact">Contact</a>
    </nav>

    <router-outlet></router-outlet>
    ```

Now, when you run `ng serve`, you can navigate between these pages without full page reloads, demonstrating the power of client-side routing.

**Tip on Testing and Debugging Routes:**

*   **Unit Testing:** You can unit test your route configurations and guards. (See [Module 13: Testing](../13-testing) for more details).
*   **Browser Developer Tools:** Use the Network tab to observe that no full page reloads occur during navigation. You can also inspect the URL in the address bar.
*   **Angular DevTools:** The Angular DevTools browser extension can help visualize the active route and router state (See [Module 15.3: Angular DevTools](../15-ecosystem/15.3-angular-devtools.md)).

---

### Key Takeaways

*   The **`Routes` array** defines the mapping between URL paths and components.
*   The **`provideRouter()`** function in `app.config.ts` sets up the router for standalone applications.
*   The **`<router-outlet>`** directive is a placeholder where routed components are rendered.
*   The **`routerLink`** directive is used for declarative, client-side navigation.
*   The order of routes in the `Routes` array is important (`**` wildcard route should be last).

---

**Previous:** [5.1 Introduction to SPA Routing](./5.1-introduction-to-spa-routing.md)

**Next:** [5.3 Route Parameters & Query Parameters](./5.3-route-parameters.md)
