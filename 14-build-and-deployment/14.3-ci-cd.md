# Module 14.3: Continuous Integration/Continuous Delivery (CI/CD)

**Objective:** To understand the principles of Continuous Integration (CI) and Continuous Delivery (CD), and how to set up a basic CI/CD pipeline for an Angular application to automate testing and deployment.

---

### The Problem: Manual, Error-Prone Processes

In traditional software development, integrating code changes, running tests, and deploying applications can be a manual, time-consuming, and error-prone process. This often leads to:

*   **Integration Hell:** Developers work in isolation for long periods, leading to complex and painful merges.
*   **Late Bug Detection:** Bugs are found late in the development cycle, making them more expensive to fix.
*   **Slow Releases:** Deployments are infrequent and risky, requiring significant manual effort.
*   **Lack of Confidence:** Uncertainty about whether new changes will break existing functionality.

### The Solution: CI/CD

**Continuous Integration (CI)** and **Continuous Delivery (CD)** are practices that automate the software delivery pipeline, from code changes to deployment. They aim to make the process faster, more reliable, and less risky.

```mermaid
%%{init: {'theme':'neutral'}}%%
graph TD
    A[Developer Commits Code] --> B{Continuous Integration (CI)};
    B --> C[Automated Build];
    B --> D[Automated Tests (Unit, Integration)];
    D -- Pass --> E[Artifact (Build Output)];
    D -- Fail --> F[Notify Developer];

    E --> G{Continuous Delivery (CD)};
    G --> H[Automated Deployment to Staging];
    H --> I[Manual Approval (Optional)];
    I --> J[Automated Deployment to Production];

    subgraph CI
        C
        D
    end

    subgraph CD
        G
        H
        I
        J
    end
```
**Alt text:** Diagram illustrating a CI/CD pipeline. A developer commits code, triggering Continuous Integration (CI) which includes automated build and automated tests. If tests pass, an artifact is created. This artifact then proceeds to Continuous Delivery (CD), involving automated deployment to staging, optional manual approval, and automated deployment to production. If tests fail, the developer is notified.

#### 1. Continuous Integration (CI)

CI is a development practice where developers frequently integrate their code changes into a central repository (e.g., `main` branch). Each integration is then verified by an automated build and automated tests.

**Key Principles of CI:**

*   **Frequent Commits:** Developers commit code multiple times a day.
*   **Automated Builds:** Every commit triggers an automated build process.
*   **Automated Testing:** Unit and integration tests run automatically to catch bugs early.
*   **Fast Feedback:** Developers receive immediate feedback on the success or failure of their changes.

#### 2. Continuous Delivery (CD)

CD is an extension of CI. It ensures that software can be released to production at any time. After the CI process, the built and tested artifact is automatically deployed to a staging environment, making it ready for release.

**Key Principles of CD:**

*   **Automated Deployment:** The process of deploying the application to various environments (staging, production) is automated.
*   **Release Readiness:** The application is always in a deployable state.
*   **Optional Manual Approval:** While deployment to staging is often automatic, deployment to production might require a manual approval step.

--- 

### CI/CD Pipeline for an Angular Application

A typical CI/CD pipeline for an Angular application involves the following stages:

#### Stage 1: Build

*   **Action:** Install dependencies, then build the Angular application for production.
*   **Command:** `npm install && ng build --configuration production`
*   **Output:** The optimized static files in the `dist/` folder.

#### Stage 2: Test

*   **Action:** Run unit tests and E2E tests.
*   **Commands:**
    *   Unit Tests: `npm test -- --no-watch --no-progress --browsers=ChromeHeadless` (for Jest/Karma)
    *   E2E Tests: `ng e2e --headless` (for Cypress)
*   **Outcome:** If tests pass, proceed. If they fail, the pipeline stops, and the developer is notified.

#### Stage 3: Deploy (to Staging)

*   **Action:** Deploy the built artifacts to a staging environment for further testing or review.
*   **Method:** This depends on your hosting provider (e.g., `firebase deploy`, `aws s3 sync`, Netlify/Vercel automatic deployment).

#### Stage 4: Deploy (to Production)

*   **Action:** Deploy the same artifacts (that passed staging tests) to the production environment.
*   **Method:** Can be manual (e.g., a button click in the CI/CD tool) or fully automated.

### Popular CI/CD Tools

Many tools can be used to implement CI/CD pipelines. Some popular choices include:

*   **GitHub Actions:** Integrated directly into GitHub repositories, easy to set up with YAML configurations.
*   **GitLab CI/CD:** Built into GitLab, highly configurable.
*   **Jenkins:** An open-source automation server, highly flexible but requires more setup.
*   **Azure DevOps Pipelines:** Microsoft's comprehensive DevOps solution.
*   **CircleCI, Travis CI, Bitbucket Pipelines:** Other cloud-based CI/CD services.

### Example: Basic GitHub Actions Workflow (`.github/workflows/angular-ci.yml`)

This YAML file defines a simple workflow that builds and tests an Angular application on every push to the `main` branch.

```yaml
name: Angular CI/CD

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20' # Use Node.js 20

    - name: Install dependencies
      run: npm ci # 'ci' is faster for CI environments

    - name: Build Angular application
      run: npm run build -- --configuration production

    - name: Run Unit Tests
      run: npm test -- --no-watch --no-progress --browsers=ChromeHeadless

    # Optional: Add E2E tests (requires a running app and Cypress setup)
    # - name: Run E2E Tests
    #   run: npm run e2e -- --headless

    # Optional: Deploy to a hosting service (e.g., Netlify, Firebase, Vercel)
    # - name: Deploy to Netlify
    #   if: success() && github.ref == 'refs/heads/main'
    #   uses: nwtgck/actions-netlify@v2.0
    #   with:
    #     publish-dir: './dist/your-app-name'
    #     production-branch: main
    #     github-token: ${{ secrets.GITHUB_TOKEN }}
    #     deploy-message: "Deploy from GitHub Actions"
    #     enable-pull-request-comment: false
    #     enable-commit-comment: true
    #   env:
    #     NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
    #     NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
```

CI/CD pipelines are essential for modern software development. They automate repetitive tasks, improve code quality, reduce risks, and enable faster, more confident releases of your Angular applications.

---

**End of Module 14.**

**Previous:** [14.2 Deployment Strategies](./14.2-deployment-strategies.md)

**Next:** [15-ecosystem](../15-ecosystem)
