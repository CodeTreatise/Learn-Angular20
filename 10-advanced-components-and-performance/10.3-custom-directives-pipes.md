# Module 10.3: Custom Directives and Pipes

**Objective:** To learn how to extend Angular's capabilities by creating your own custom attribute directives to add behavior to elements, and custom pipes to transform data for display.

---

### 1. Custom Attribute Directives

As seen in Module 2.3, attribute directives modify the appearance or behavior of an existing DOM element or component. While Angular provides built-in attribute directives like `ngClass` and `ngStyle`, you can create your own to encapsulate reusable UI logic.

**When to create a custom attribute directive:**

*   You need to add specific behavior to an element (e.g., a tooltip, a drag-and-drop handler, a highlight effect).
*   You want to manipulate the DOM directly (e.g., changing styles, adding/removing classes).
*   You want to listen to DOM events on the host element.

#### a) Generating a Directive

Use the Angular CLI to generate a new directive:

```bash
ng generate directive highlight
# or short form
ng g d highlight
```

This will create `src/app/highlight.directive.ts` and `src/app/highlight.directive.spec.ts`.

#### b) Anatomy of a Custom Attribute Directive

```typescript
// src/app/highlight.directive.ts
import { Directive, ElementRef, HostListener, Input } from '@angular/core';

@Directive({
  standalone: true, // Directives can also be standalone
  selector: '[appHighlight]' // The CSS selector for this directive
})
export class HighlightDirective {
  // Inject ElementRef to get a reference to the host DOM element
  constructor(private el: ElementRef) { }

  // @Input() to allow passing data to the directive
  @Input() appHighlight: string = ''; // The value passed to the directive
  @Input() defaultColor: string = 'yellow';

  // @HostListener to listen for events on the host element
  @HostListener('mouseenter') onMouseEnter(): void {
    this.highlight(this.appHighlight || this.defaultColor);
  }

  @HostListener('mouseleave') onMouseLeave(): void {
    this.highlight(''); // Remove highlight
  }

  private highlight(color: string): void {
    this.el.nativeElement.style.backgroundColor = color;
  }
}
```

**Key Concepts:**

*   **`@Directive()` Decorator:** Marks the class as an Angular directive.
*   **`selector: '[appHighlight]'`:** This is a CSS attribute selector. It means the directive will be applied to any HTML element that has an attribute named `appHighlight` (e.g., `<p appHighlight>`).
*   **`ElementRef`:** Injected into the constructor, `ElementRef` provides a direct reference to the host DOM element on which the directive is placed. Use it with caution, as direct DOM manipulation can bypass Angular's change detection.
*   **`@Input()`:** Allows data to be passed into the directive from the component's template. The input property name typically matches the selector name (`appHighlight`).
*   **`@HostListener()`:** Decorator that allows you to listen for events on the host DOM element and execute a method in your directive when that event occurs.

#### c) Using the Custom Directive

To use a standalone directive, you must import it into the `imports` array of the component where it's being used.

```typescript
// src/app/app.component.ts
import { Component } from '@angular/core';
import { HighlightDirective } from './highlight.directive'; // Import the directive

@Component({
  standalone: true,
  selector: 'app-root',
  imports: [HighlightDirective], // Add to imports array
  template: `
    <p appHighlight="lightblue">Highlight this text with lightblue.</p>
    <p appHighlight defaultColor="lightgreen">Highlight this text with default green.</p>
    <p appHighlight>Highlight with default yellow (if appHighlight is empty).</p>
  `
})
export class AppComponent { }
```

--- 

### 2. Custom Pipes

Pipes are simple functions that you can use in your templates to transform data before it's displayed. Angular provides built-in pipes like `DatePipe`, `CurrencyPipe`, and `JsonPipe`. You can create your own for custom data transformations.

**When to create a custom pipe:**

*   You need to format data for display (e.g., phone numbers, social security numbers, custom date formats).
*   You want to filter or sort lists directly in the template.
*   The transformation is stateless and doesn't involve side effects.

#### a) Generating a Pipe

Use the Angular CLI to generate a new pipe:

```bash
ng generate pipe phone-number
# or short form
ng g p phone-number
```

This will create `src/app/phone-number.pipe.ts` and `src/app/phone-number.pipe.spec.ts`.

#### b) Anatomy of a Custom Pipe

```typescript
// src/app/phone-number.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  standalone: true, // Pipes can also be standalone
  name: 'phoneNumber' // The name used in the template
})
export class PhoneNumberPipe implements PipeTransform {
  // The transform method is where the transformation logic resides
  transform(value: string | number, countryCode?: string): string {
    if (!value) return '';

    let phoneStr = value.toString().replace(/\D/g, ''); // Remove non-digits

    if (countryCode === 'US') {
      // Format for US: (123) 456-7890
      if (phoneStr.length === 10) {
        return `(${phoneStr.substring(0, 3)}) ${phoneStr.substring(3, 6)}-${phoneStr.substring(6)}`;
      }
    } else if (phoneStr.length >= 10) {
      // Generic international format (simplified)
      return `+${phoneStr.substring(0, 2)} ${phoneStr.substring(2, 5)} ${phoneStr.substring(5, 8)} ${phoneStr.substring(8)}`;
    }

    return phoneStr; // Return as is if no format matches
  }
}
```

**Key Concepts:**

*   **`@Pipe()` Decorator:** Marks the class as an Angular pipe.
*   **`name: 'phoneNumber'`:** The name you will use to invoke the pipe in your templates (e.g., `{{ value | phoneNumber }}`).
*   **`PipeTransform` Interface:** You must implement this interface, which requires the `transform()` method.
*   **`transform(value: any, ...args: any[])`:** This method contains the logic for transforming the `value`. Additional arguments can be passed to the pipe.

#### c) Using the Custom Pipe

To use a standalone pipe, you must import it into the `imports` array of the component where it's being used.

```typescript
// src/app/app.component.ts
import { Component } from '@angular/core';
import { PhoneNumberPipe } from './phone-number.pipe'; // Import the pipe

@Component({
  standalone: true,
  selector: 'app-root',
  imports: [PhoneNumberPipe], // Add to imports array
  template: `
    <p>US Phone: {{ '1234567890' | phoneNumber:'US' }}</p>
    <p>International Phone: {{ '919876543210' | phoneNumber }}</p>
  `
})
export class AppComponent { }
```

### Pure vs. Impure Pipes

By default, pipes are **pure**. This means Angular only re-executes the pipe's `transform` method when its input value (or arguments) changes. This is highly performant.

An **impure** pipe (set `pure: false` in `@Pipe` decorator) is re-executed during every change detection cycle. This can have significant performance implications and should be used with extreme caution, typically only for pipes that rely on mutable objects or external state.

Custom directives and pipes are powerful tools for extending Angular's capabilities and promoting code reusability. They allow you to encapsulate specific behaviors and transformations, keeping your components clean and focused on their primary responsibilities.

---

**Previous:** [10.2 Content Projection with `ng-content`](./10.2-content-projection.md)

**Next:** [10.4 Change Detection Strategy: OnPush](./10.4-change-detection-onpush.md)
